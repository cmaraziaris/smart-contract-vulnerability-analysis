
# Attack #5: Popsicle Swap

## Attack Classification

"double spending", broken reward claim mechanism, generation of infinite reward tokens, Resulted in money loss (>$20M)

Wrong assumption: Every user must have done at least 1 deposit before claiming rewards.

## Attack Vector

The attack vector is described in full detail [here](https://blocksecteam.medium.com/the-analysis-of-the-popsicle-finance-security-incident-9d9d5a3045c1) and [here](https://rekt.news/popsicle-rekt/).

### Brief Description

The vulnerable contract (called "SorbettoFragola") manages Uniswap V3 Liquidity pools (effectively a yield optimization front-end of Uni), aiming to make profit for its users.
Any contract can deposit tokens to a Uniswap pool managed by the SorbettoFragola (SF) contract.
The contract will then gain PLP (ERC-20) tokens, used to later withdraw the deposited amount and claim fees.
The vulnerability allowed anyone to deposit an amount of legitimate tokens, get PLP tokens in return, and then transfer the PLP tokens to different contracts and claim rewards from the SF contract in a sequential fashion.
The result is that with only 1 deposit, an attacker can claim rewards as if they performed N deposits of the initial amount, where N is the number of links in the chain, thus draining the SF pool completely (since N is unbounded).
The attacker can then withdraw the single deposit along with the N rewards.


<!-- The vulnerability exists in the Reward Calculation function, which uses the value of "token per PLP share" at the time of deposit, to calculate the  -->


### Vulnerable Code

View the full code on [Etherscan](https://etherscan.io/address/0x98d149e227C75D38F623A9aa9F030fB222B3FAa3#code).

```solidity
    /**
     * @notice Used to withdraw accumulated user's fees.
     */
    function collectFees(uint256 amount0, uint256 amount1) external nonReentrant updateVault(msg.sender) {
        // [...]
    }

    // Function modifier that calls update fees reward function
    modifier updateVault(address account) {
        _updateFeesReward(account);  // VULN: Vulnerability exploited here
        _;
    }

    // Updates user's fees reward
    function _updateFeesReward(address account) internal {
        uint liquidity = pool.positionLiquidity(tickLower, tickUpper);
        if (liquidity == 0) return; // we can't poke when liquidity is zero
        (uint256 collect0, uint256 collect1) = _earnFees();
        
        token0PerShareStored = _tokenPerShare(collect0, token0PerShareStored);
        token1PerShareStored = _tokenPerShare(collect1, token1PerShareStored);

        if (account != address(0)) {
            UserInfo storage user = userInfo[msg.sender];
            user.token0Rewards = _fee0Earned(account, token0PerShareStored);  // VULN: Unreasonably large value returned
            user.token0PerSharePaid = token0PerShareStored;
            
            user.token1Rewards = _fee1Earned(account, token1PerShareStored);
            user.token1PerSharePaid = token1PerShareStored;
        }
    }
    
    // Calculates how much token0 is entitled for a particular user
    function _fee0Earned(address account, uint256 fee0PerShare_) internal view returns (uint256) {
        UserInfo memory user = userInfo[account];
        return
            balanceOf(account)                                // VULN: user.token0PerSharePaid is 0 on accounts with 0 deposits.
            .mul(fee0PerShare_.sub(user.token0PerSharePaid))  // .sub() is supposed to subtract a large value, namely the token0PerSharePaid at the time of depositing.
            .unsafeDiv(1e18)                                  // This is actually the first lookup for "account" in "userInfo" map, thus returning 0
            .add(user.token0Rewards);  // Ultimately, the returned value is the number of PLP shares times the most recent token0PerSharePaid value
    }

    // Calculates how much token is provided per LP token 
    function _tokenPerShare(uint256 collected, uint256 tokenPerShareStored) internal view returns (uint256) {
        uint _totalSupply = totalSupply();
        if (_totalSupply > 0) {
            return tokenPerShareStored  // NOTE: Incremental operation, tokenPerShareStored only increases.
            .add(
                collected
                .mul(1e18)
                .unsafeDiv(_totalSupply)
            );
        }
        return tokenPerShareStored;
    }

```

### Attack Scheme

The vulnerability can be exploited in the following scenario:
1) Contract A deposits X amount of token0 and Y amount of token1 to an SF contract, and gets Z PLP tokens in return. `A calls SF.deposit(X, Y);`
2) Contract A transfers Z PLP tokens to Contract B. `A calls PLP.transfer(B, Z);`
3) Contract B updates its rewards. `B calls SF.collectFees(0,0);`
4) Contract B transfers Z PLP tokens to Contract C. `B calls PLP.transfer(C, Z);`
5) Contract C updates its rewards. `C calls SF.collectFees(0,0);`
6) Contract C transfers Z PLP tokens to Contract A. `C calls PLP.transfer(A, Z);`
7) Contract A withdraws the full initial amount deposited. `A calls SF.withdraw(Z);`
8) Contract B claims rewards, namely an R0 tokens of token0 and R1 tokens of token1. `B calls SF.collectFees(R0, R1);`
9) Contract C claims rewards, namely an R0 tokens of token0 and R1 tokens of token1. `C calls SF.collectFees(R0, R1);`
10) (Optional) B and C transfer the collected tokens to A or to the owner.

Note: In steps 8 and 9 the exact values of R0 and R1 need to be experimented with, since it is possible that the rewards claimed exceed the total liquidity of the pool, and thus the reward transfer will fail.

#### Mitigation

This attack is probably prevented by ensuring that only *actual* depositors (contracts that have deposited at least once in the said SF contract) can call the *collectFees* function.


### Simulate the Attack

Inside `~/hardhat-projects/popsicle-rekt/` run:

Terminal #0:

```bash
$ npx hardhat node
```

Terminal #1:
```bash
$ node scripts/execute.js
```

The code implementing contract A (the initiator of the attack) can be found in `AttackInit.sol` and the implementation of the contracts B, C (the contracts that do not deposit but claim the rewards) can be found in the file `SorbettoFragola.sol [ln:2857-2880]`.

The initial capital is obtained by the use of AAVE Flash Loans, as in the actual attack.

Finally, you should end up with around $20M in varius tokens credited to the attacker's personal account in Terminal #0.