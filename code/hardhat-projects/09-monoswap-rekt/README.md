
# Attack #9: MONOSWAP

## Attack Classification

Artificial price manipulation, faulty swap logic, resulted in money loss (>$30M)


## Attack Vector

Bug allowed to swap with the same token as input and output, thus pumping its price without any change in the pool assets.

The attack vector is described in full detail [here](https://medium.com/monoswap/exploit-post-mortem-33921a779b43) and [here](https://rekt.news/monox-rekt/).


### Brief Description

The exploit was caused by a smart contract bug that allows the sold and bought token to be the same. In the case of the attack, it was our native MONO token. When a swap was taking place and tokenIn was the same as tokenOut, the transaction was permitted by the contract.

Any price updates from swap from tokenIn and tokenOut were independently verified by the contract. With tokenOut being verified last, this caused a massive price appreciation of MONO. The attacker then used the highly priced MONO to purchase all the other assets in our pool and drained the funds.


### Vulnerable Code

View the full code on [Etherscan](https://etherscan.io/address/0x66e7d7839333f502df355f5bd87aea24bac2ee63#code).

```solidity
  function swapExactTokenForToken(
    address tokenIn,
    address tokenOut,
    uint amountIn,
    uint amountOutMin,
    address to,
    uint deadline
  ) external virtual ensure(deadline) returns (uint amountOut) {
    amountOut = swapIn(tokenIn, tokenOut, msg.sender, to, amountIn); // VULN
    require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');  // tokenIn == tokenOut
  }

  // swap from tokenIn to tokenOut with fixed tokenIn amount.
  function swapIn (address tokenIn, address tokenOut, address from, address to,
      uint256 amountIn) internal lockToken(tokenIn) returns(uint256 amountOut)  {

    address monoXPoolLocal = address(monoXPool);

    amountIn = transferAndCheck(from,monoXPoolLocal,tokenIn,amountIn); 
    
    // uint256 halfFeesInTokenIn = amountIn.mul(fees)/2e5;

    uint256 tokenInPrice;
    uint256 tokenOutPrice;
    uint256 tradeVcashValue;
    
    (tokenInPrice, tokenOutPrice, amountOut, tradeVcashValue) = getAmountOut(tokenIn, tokenOut, amountIn);

    uint256 oneSideFeesInVcash = tokenInPrice.mul(amountIn.mul(fees)/2e5)/1e18;

    // trading in
    if(tokenIn==address(vCash)){
      vCash.burn(monoXPoolLocal, amountIn);
      // all fees go to the other side
      oneSideFeesInVcash = oneSideFeesInVcash.mul(2);
    }else{
      _updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);  // VULN: Price of tokenIn decreases
    }

    // trading out
    if(tokenOut==address(vCash)){
      vCash.mint(to, amountOut);
    }else{
      if (to != monoXPoolLocal) {
        IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);
      }
      _updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0, 
        to == monoXPoolLocal ? amountOut : 0);  // VULN: Price of tokenIn increases
    }

    // VULN: Since tokenIn == tokenOut and the increase discards the decrease completely, MONO price is pumped up

    if(pools[tokenIn].vcashDebt > 0 && pools[tokenIn].status == PoolStatus.OFFICIAL){
      _internalRebalance(tokenIn);
    }

    emit Swap(to, tokenIn, tokenOut, amountIn, amountOut, tradeVcashValue);
  }
```

### Attack Scheme

The vulnerability can be exploited in the following scenario, where A is the attacking contract:
1) A obtains MONO (for example, by swapping WETH for MONO).
2) (Optional) A removes all of the liquidity in the MONO token pool (feasible due to outstanding approvals) and then adds a bit himself. This allows for faster price manipulation.
3) A performs a series of MONO-MONO swaps, exploiting the bug and pumping up the price of MONO.
4) A swaps the (now) valuable MONO for other assets in the MONO pools (such as USDC, WETH etc).


#### Mitigation

This attack is probably prevented by 1) forbidding the usage of the same address as `tokenIn` and `tokenOut` in the same function call or 2) by saving the effects of the price decrease, only to be cancelled out by the later increase (instead of the increase *overwritting* the decrease).

### Simulate the Attack

Inside `~/hardhat-projects/9-monoswap-rekt/` run:

Terminal #0:

```bash
$ npx hardhat node
```

Terminal #1:
```bash
$ node scripts/execute.js
```

We simulated [this transaction](https://etherscan.io/tx/0x9f14d093a2349de08f02fc0fb018dadb449351d0cdb7d0738ff69cc6fef5f299) and swapped for USDC, USDT, WETH and WBTC.

Finally, you should end up with around $12M in USDC, USDT, WETH and WBTC credited to the attacker's contract in Terminal #0.
