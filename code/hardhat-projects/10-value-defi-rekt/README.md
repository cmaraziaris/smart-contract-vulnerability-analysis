
# Attack #10: Value DeFi

## Attack Classification

Oracle manipulation, Flash Loan assisted attack, resulted in money loss (>$5M)


## Attack Vector

Attacker used flash loans to impact Curve's spot price, which was used as an oracle from Value DeFi. This resulted in 3crv being momentarily undervalued by Value, allowing the attacker to claim more 3crv than he should.

The attack vector is described in full detail [here](https://valuedefi.medium.com/multistables-vault-exploit-post-mortem-d11b0635788f) and [here](https://rekt.news/value-defi-rekt/).


### Brief Description

Value DeFi used Curve's 3pool USDC spot price as an oracle to calculate the convertion rate of **bcrv** and **ccrv** tokens to **3crv**.
The attacker used flash loans to drain the 3pool of USDC. This resulted in **bcrv** and **ccrv** to be considered overvalued by Value DeFi, and thus were converted to more **3crv** tokens than they actually should. The calculation involved converting **bcrv** and **ccrv** to USDC and then depositing USDC in 3pool, so since the 3pool had no USDC, it would generate more 3crv tokens.


The attacker minted 25M mvUSD tokens, by depositing to Value, which were worth 25M 3crv at the time of the deposit.
He then manipulated the 3pool USDC supply and withdrew his 25M mvUSD for 33M 3crv, which he then converted to stablecoins.


### Vulnerable Code

View the full code on [Etherscan](https://etherscan.io/address/0x57cda125d0c7b146a8320614ccd6c55999d15bf2#code).

Here we present the function which calculates the convertion rate from BCrv and CCrv to 3Crv.
It does that by converting BCrv to USDC and then calculates the 3Crv based on depositing USDC in the 3pool.

```solidity

    function convert_shares_rate(address _input, address _output, uint _inputAmount) external override view returns (uint _outputAmount) {
        if (_output == address(token3CRV)) {
            if (_input == address(tokenBCrv)) { // convert from BCrv -> 3CRV
                uint[3] memory _amounts;
                _amounts[1] = depositBUSD.calc_withdraw_one_coin(_inputAmount, 1); // BCrv -> USDC
                _outputAmount = stableSwap3Pool.calc_token_amount(_amounts, true); // USDC -> 3CRV
            } else if (_input == address(tokenSCrv)) { // convert from SCrv -> 3CRV
                uint[3] memory _amounts;
                _amounts[1] = depositSUSD.calc_withdraw_one_coin(_inputAmount, 1); // SCrv -> USDC
                _outputAmount = stableSwap3Pool.calc_token_amount(_amounts, true); // USDC -> 3CRV
            } else if (_input == address(tokenHCrv)) { // convert from HCrv -> 3CRV
                _outputAmount = stableSwapHUSD.calc_withdraw_one_coin(_inputAmount, 1); // HCrv -> 3CRV
            } else if (_input == address(tokenCCrv)) { // convert from CCrv -> 3CRV
                uint[3] memory _amounts;
                uint usdc = depositCompound.calc_withdraw_one_coin(_inputAmount, 1); // CCrv -> USDC
                _amounts[1] = usdc;//convert_usdc_to_cusdc(usdc); // TODO: to implement
                _outputAmount = stableSwap3Pool.calc_token_amount(_amounts, true); // USDC -> 3CRV
            }
        } else if (_output == address(tokenBCrv)) {
        	[...]
        }
        [...]
    }
```

### Attack Scheme

The vulnerability can be exploited in the following scenario, where A is the attacking contract:
1) A obtains DAI and USDT (for example, via FL)
2) A deposits DAI in the MultiStables vault of Value DeFi to obtain X mvUSD.
3) A swaps DAI and USDT in exchange for USDC in Curve's 3pool.
4) A withdraws X mvUSD from Value to obtain 3crv.
5) A converts 3crv to stablecoins and repays loans.

Due to the oracle manipulation in step 3, the final 3crv tokens obtained in step 4 are disproportional to the inital 3crv tokens (indirectly) obtained in step 2.

#### Mitigation

In order to prevent this attack, the oracle logic should be changed to not depend in 1 of the 3 tokens in the 3pool.

### Simulate the Attack

Inside `~/hardhat-projects/10-value-defi-rekt/` run:

Terminal #0:

```bash
$ npx hardhat node
```

Terminal #1:
```bash
$ node scripts/execute.js
```

We simulated [this transaction](https://etherscan.io/tx/0x46a03488247425f845e444b9c10b52ba3c14927c687d38287c0faddc7471150a).

Finally, you should end up with around $5M DAI credited to the attacking contract in Terminal #0.