
# Attack #4: punk.protocol

## Attack Classification

Missing Access Control, No proper caller-input validation, Resulted in money loss ($3M of >$8M possible)

## Attack Vector

The attack vector is described in full detail [here](https://rekt.news/punkprotocol-rekt/) and [here](https://medium.com/punkprotocol/punk-finance-fair-launch-incident-report-984d9e340eb).


### Brief Description

The root cause of the attack is a missing Modifier in the `initialize()` function.
The attacker just called the publicly-visible `initialize()` to replace what should have been the protocol’s `forgeAddress` with their own malicious contract.
The lack of an “initializer” Modifier meant that the manipulated function was executed despite being associated with an unknown (and in this case malicious) contract.
With the contract address now updated, the attacker was then able to call `withdrawToForge`, sending the assets controlled by the CompoundModel directly to the malicious contract, and into their wallet.
Although the withdrawal mechanisms are protected by the `OnlyForge` Modifier, the `initialize()` function had already defined the malicious contract as the `forgeAddress`, and as such `OnlyForge` did not detect any abnormality.


### Vulnerable Code

View the full code on [Github](https://github.com/PunkFinance/punk.protocol/blob/4e4d570f470cdbd53163cf227d35f4c98119059b/contracts/models/CompoundModel.sol#L24-L39).

```solidity
    // CompoundModel.sol

    function initialize( 
        address forge_, 
        address token_,
        address cToken_, 
        address comp_, 
        address comptroller_,
        address uRouterV2_ ) public {  // VULN: Can be called by anyone with custom arguments!
            addToken( token_ );
            setForge( forge_ );  // VULN: forge_ is set to be a malicious contract.
            _cToken         = cToken_;
            _comp           = comp_;
            _comptroller    = comptroller_;
            _uRouterV2      = uRouterV2_;
    }

    function withdrawTo( uint256 amount, address to ) public OnlyForge override{
        uint oldBalance = IERC20( token(0) ).balanceOf( address( this ) );
        CTokenInterface( _cToken ).redeemUnderlying( amount );
        uint newBalance = IERC20( token(0) ).balanceOf( address( this ) );
        require(newBalance.sub( oldBalance ) > 0, "MODEL : REDEEM BALANCE IS ZERO");
        IERC20( token( 0 ) ).safeTransfer( to, newBalance.sub( oldBalance ) );
        
        emit Withdraw( amount, forge(), block.timestamp);
    }

    // ModelStorage.sol

    /**
     * @dev This modifier allows only "Forge" to be executed.
     */
    modifier OnlyForge(){
        require(_forge == msg.sender, "MODEL : Only Forge");
        _;
    }

    /**
     * @dev A model must have only one Forge.
     * 
     * IMPORTANT: 'Forge' should be non-replaceable by default.
     */
    function setForge( address forge_ ) internal returns( bool ){
        _forge = forge_;
        return true;
    }
```

The `initialize()` function sets the `forge_` address, which controls the user funds deposited in various pools.

### Attack Scheme

The attacker calls `initialize()` with his custom contract address as the `forge_` argument and then withdraws the underlying assets deposited in the Compound pools by calling `withdrawTo()` to his malicious contract.

This is feasible because the attacker can install any address as the `forge_` address. Note that in the `setForge()` function above there is a comment:
`* IMPORTANT: 'Forge' should be non-replaceable by default.`
which is not implemented in code (for example, by a lock after the initial call to `setForge()` or by an `OnlyAdmin` modifier).
This allows the attacker to also bypass the `OnlyForge` modifier in the `withdrawTo()` function, since he effectively set his contract as a legitimate `forge` contract.
The attacker proceeds to drain all funds from the Compound pools of DAI, USDC, USDT.

#### Mitigation

The attack is effectively prevented by either using a lock in the `setForge()` function (complying to the comments) or by adding an `OnlyAdmin` or `OnlyGovernance` modifier in the `initialize()` function.


### Simulate the Attack

Inside `~/hardhat-projects/punk-protocol-rekt/` run:

Terminal #0:

```bash
$ npx hardhat node
```

Terminal #1:
```bash
$ node scripts/execute.js
```

You should end up with around $3M USDC credited to the attacker's account in Terminal #0.

## Notes

The potential loss of funds from all 3 Compound pools is around $8M. However, due to a front-run bot interference, the attacker is only able to get $3M USDC while the rest $5M of DAI and USDT go to the front-runner. In our implementation, the front-running bot is also in play, and that's why the attacker ultimately only benefits from USDC (while he obtains 0 DAI and USDT).
