// SPDX-License-Identifier: MIT
/**
 *Submitted for verification at Etherscan.io on 2021-01-05
*/

pragma solidity ^0.6.0;

import "./Interfaces.sol";
import "./ILendingPool.sol";

import "hardhat/console.sol";


// interface CTokenInterface  {
//     function totalSupply() external view returns (uint256 supply);
//     function balanceOf(address _owner) external view returns (uint256 balance);
//     function transfer(address _to, uint256 _value) external returns (bool success);
//     function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
//     function approve(address _spender, uint256 _value) external returns (bool success);
//     function allowance(address _owner, address _spender) external view returns (uint256 remaining);
//     function decimals() external view returns (uint256 digits);
//     event Approval(address indexed _owner, address indexed _spender, uint256 _value);
//     // function mint(uint256 mintAmount) external returns (uint256);
//     // function mint() external payable;
//     function redeem(uint256 redeemTokens) external returns (uint256);
//     function redeemUnderlying(uint256 redeemAmount) external returns (uint256);
// }


// contract DSAuthority {
//     function canCall(
//         address src, address dst, bytes4 sig
//     ) public view returns (bool);
// }
contract DSAuthEvents {
    event LogSetAuthority (address indexed authority);
    event LogSetOwner     (address indexed owner);
}
contract DSAuth is DSAuthEvents {
    // DSAuthority  public  authority;
    address      public  owner;
    constructor() public {
        owner = msg.sender;
        emit LogSetOwner(msg.sender);
    }
    function setOwner(address owner_)
        public
        auth
    {
        owner = owner_;
        emit LogSetOwner(owner);
    }
    // function setAuthority(DSAuthority authority_)
    //     public
    //     auth
    // {
    //     authority = authority_;
    //     emit LogSetAuthority(authority);
    // }
    modifier auth {
        // require(isAuthorized(msg.sender, msg.sig), "Rev3");
        _;
    }
    // function isAuthorized(address src, bytes4 sig) internal view returns (bool) {
    //     if (src == address(this)) {
    //         return true;
    //     } else if (src == owner) {
    //         return true;
    //     } else if (authority == DSAuthority(0)) {
    //         return false;
    //     } else {
    //         return authority.canCall(src, this, sig);
    //     }
    // }
}
contract DSNote {
    event LogNote(
        bytes4   indexed  sig,
        address  indexed  guy,
        bytes32  indexed  foo,
        bytes32  indexed  bar,
        uint              wad,
        bytes             fax
    ) anonymous;
    modifier note {
        bytes32 foo;
        bytes32 bar;
        assembly {
            foo := calldataload(4)
            bar := calldataload(36)
        }
        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);
        _;
    }
}
contract DSProxyCache {
    mapping(bytes32 => address) cache;
    function read(bytes memory _code) public view returns (address) {
        bytes32 hash = keccak256(_code);
        return cache[hash];
    }
    function write(bytes memory _code) public returns (address target) {
        assembly {
            target := create(0, add(_code, 0x20), mload(_code))
            switch iszero(extcodesize(target))
            case 1 {
                // throw if contract failed to deploy
                revert(0, 0)
            }
        }
        bytes32 hash = keccak256(_code);
        cache[hash] = target;
    }
}
contract DefiSaverWallet is DSAuth, DSNote, FlashLoanReceiverBase {
    DSProxyCache public cache;  // global cache for contracts

    using SafeERC20 for ERC20;

    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);

    // address public owner;

    constructor(address owner) public
    FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER)
    {
        setOwner(owner);
    }

    // receive() external payable { }

    fallback() external payable {
        console.log("[AtkProxy] Yo, I received some funds.");
    }
    // use the proxy to execute calldata _data on contract _code
    function execute(bytes memory _code, bytes memory _data)
        public
        payable
        returns (address target, bytes32 response)
    {

        // console.log("[AtkProxy] execute1 called.");

        target = cache.read(_code);
        if (target == address(0x0)) {
            // deploy contract & store its address in cache
            target = cache.write(_code);
        }
        response = execute(target, _data);
    }
    function execute(address _target, bytes memory _data)
        public
        auth
        payable
        returns (bytes32 response)
    {
        // console.log("[AtkProxy] execute2 called.");

        require(_target != address(0x0), "Rev0");
        // call contract in current context
        assembly {
            let succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 32)
            response := mload(0)      // load delegatecall output
            switch iszero(succeeded)
            case 1 {
                // throw if delegatecall failed
                revert(0, 0)
            }
        }
    }
    //set new cache
    function setCache(address _cacheAddr)
        public
        auth
        returns (bool)
    {
        require(_cacheAddr != address(0x0), "Rev1");        // invalid cache address
        cache = DSProxyCache(_cacheAddr);  // overwrite cache
        return true;
    }


    address payable cWBTC_addr = 0xC11b1268C1A384e55C48c2391d8d480264A3A7F4;
    address payable cUSDC_addr = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;
    address payable USDC_addr = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address payable WBTC_addr = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;

    function getUSDC_Balance() public {
        uint256 balance = ERC20(USDC_addr).balanceOf(address(this));
        console.log("Balance of USDC is: ", balance);
    }

    function getcUSDC_Balance() public {
        uint256 balance = ERC20(cUSDC_addr).balanceOf(address(this));
        console.log("Balance of cUSDC is: ", balance);
    }

    function getcWBTC_Balance() public {
        uint256 balance = ERC20(cWBTC_addr).balanceOf(address(this));
        console.log("Balance of cWBTC is: ", balance);
    }

    function getWBTC_Balance() public {
        uint256 balance = ERC20(WBTC_addr).balanceOf(address(this));
        console.log("Balance of WBTC is: ", balance);
    }

    function getBalances() public {
        console.log("\nBalances:\n---------------\n");
        getcWBTC_Balance();
        getcUSDC_Balance();
        getWBTC_Balance();
        getUSDC_Balance();
    }


    function sendCTokens(address _to) public {
        // 1) Get a Flash Loan in USDC 
        getBalances();

        bytes memory data = "";
        uint256 borrowAmount = CTokenInterface(cUSDC_addr).borrowBalanceCurrent(address(this));
        console.log("borrowAmount (USDC) is: ", borrowAmount);

        ILendingPool lendingPool = ILendingPool(addressesProvider.getLendingPool());
        lendingPool.flashLoan(address(this), USDC_addr, borrowAmount, data);

        console.log("\n>>> After (5) <<< ");
        getBalances();

        uint256 totalUSDCBalance = ERC20(USDC_addr).balanceOf(address(this));
        ERC20(USDC_addr).transfer(_to, totalUSDCBalance);
    }


    function executeOperation(
        address _reserve,
        uint256 _amount,
        uint256 _fee,
        bytes calldata _params)
    external override {

        console.log("\n>>> After (1) <<< ");
        getBalances();

        // 2) Repay Compound loan of cUSDC
        uint256 debtLeft = CTokenInterface(cUSDC_addr).borrowBalanceCurrent(address(this));
        console.log("Debt left (USDC) is: ", debtLeft);

        ERC20(USDC_addr).approve(cUSDC_addr, debtLeft);
        CTokenInterface(cUSDC_addr).repayBorrow(debtLeft);

        debtLeft = CTokenInterface(cUSDC_addr).borrowBalanceCurrent(address(this));
        console.log("New Debt left (USDC) is: ", debtLeft);

        console.log("\n>>> After (2) <<< ");
        getBalances();


        // 3) Redeem cWBTC from Compound

        uint256 totalCWBTCBalance = CTokenInterface(cWBTC_addr).balanceOf(address(this));
        CTokenInterface(cWBTC_addr).redeem( totalCWBTCBalance );

        uint256 totalWBCTBalance = ERC20(WBTC_addr).balanceOf(address(this));

        console.log("\n>>> After (3) <<< ");
        getBalances();

        // 4) Convert WBTC to USDC

        swap(WBTC_addr, USDC_addr, totalWBCTBalance, 10, address(this));


        console.log("\n>>> After (4) <<< ");
        getBalances();

        // 5) Repay the Flash Loan

        // Repay the loan with the money DSProxy sent back
        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));
    }


    function swap( address _tokenIn, address _tokenOut, uint _amountIn, uint _amountOutMin, address _to) public {

        address payable UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
        address payable WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

        // ERC20(_tokenIn).transferFrom(msg.sender, address(this), _amountIn);
        ERC20(_tokenIn).approve(UNISWAP_V2_ROUTER, _amountIn);

        address[] memory path;
        if (_tokenIn == WETH || _tokenOut == WETH) {
            path = new address[](2);
            path[0] = _tokenIn;
            path[1] = _tokenOut;
        } else {
            path = new address[](3);
            path[0] = _tokenIn;
            path[1] = WETH;
            path[2] = _tokenOut;
        }

        IUniswapV2Router(UNISWAP_V2_ROUTER).swapExactTokensForTokens(
            _amountIn,
            _amountOutMin,
            path,
            _to,
            block.timestamp
        );
    }
}


// 1) Get a Flash Loan in USDC 
// 2) Repay Compound loan of cUSDC
// 3) Redeem cWBTC from Compound
// 4) Convert WBTC to USDC
// 5) Repay the Flash Loan