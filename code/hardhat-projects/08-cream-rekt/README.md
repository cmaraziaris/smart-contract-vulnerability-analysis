
# Attack #8: C.R.E.A.M.

## Attack Classification

reentrancy, ERC-777 transfer hooks, missing check-effect-interaction pattern, resulted in money loss (>$7M)

Wrong assumption: Existing code for ERC-20 tokens is also secure to handle ERC-777 tokens.

## Attack Vector

The attack vector is described in full detail [here](https://medium.com/cream-finance/c-r-e-a-m-finance-post-mortem-amp-exploit-6ceb20a630c5) and [here](https://rekt.news/cream-rekt/).


### Brief Description

The main cause of this attack is the attacker's ability to nest 2 `borrow` functions with the help of the ERC-777 token pre/post-transfer hooks. The 2nd `borrow` allowed the attacker to borrow ETH against the same collateral used for the token of the 1st borrow (the 1st borrow effects were not updated in the contract), thus profiting from the extra amount borrowed.


### Vulnerable Code

View the full code on [Etherscan](https://etherscan.io/address/0xd06527d5e56a3495252a528c4987003b712860ee#code).

Here we present the code for the `crETH` token. The `crAMP` is similar. We can see that there is a `nonReentrant` modifier in the chain of function calls starting from `borrow`. However, the attacker called `crAMP.borrow` which then called `crETH.borrow` (so external call to a different contract), an action which is outside the contract-scope of the modifier, and thus allowing reentrancy (on a protocol level).

```solidity
/* `crETH` token */
    function borrow(uint borrowAmount) external returns (uint) {
        return borrowInternal(borrowAmount);
    }

    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        // [...]
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(borrower, borrowAmount);  // EXPLOIT HAPPENS HERE

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    function doTransferOut(address payable to, uint amount) internal {
        /* Send the Ether, with minimal gas and revert on failure */
        to.transfer(amount);
    }
```

### Attack Scheme

The vulnerability can be exploited in the following scenario, where A and B are the 2 malicious contracts:
1) A registers his `tokensReceived` post-transfer hook in the ERC1820 registry.
2) A obtains WETH (via Flash Loan or else).
3) A uses the WETH to mint crETH, then borrows x AMP against crETH. Since AMP is an ERC-777 token, the `tokensReceived` function is called, thus A is able to borrow more crETH.
4) A sends x/2 AMP to B.
5) B `liquidateBorrow`s part of A's AMP loan against crETH, redeems the obtained crETH and transfers the ETH to A.
6) A converts ETH to WETH, repays the FL, and leaves with a profit of WETH and AMP tokens.

This process was used 17 times in the actual exploit.

#### Mitigation

This attack is probably prevented by introducing reentrancy guards in the CREAM tokens' `borrow` functions, implemented in a protocol level (since contract-level guards already exist).

### Simulate the Attack

Inside `~/hardhat-projects/8-cream-rekt/` run:

Terminal #0:

```bash
$ npx hardhat node
```

Terminal #1:
```bash
$ node scripts/execute.js
```

We simulated [this transaction](https://etherscan.io/tx/0xa9a1b8ea288eb9ad315088f17f7c7386b9989c95b4d13c81b69d5ddad7ffe61e) (the 1st out of the 17 total malicious tx).

Finally, you should end up with around `37 WETH` (about $120k) and `9.740.000 AMP` tokens credited to the attacker's contract in Terminal #0.
