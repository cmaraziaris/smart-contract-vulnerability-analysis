
# Attack #12: TempleDAO - Stax Staking

## Attack Classification

Missing Access Control, No proper caller-input validation, Resulted in money loss ($2.3M)


## Attack Vector

The attack vector is described in full detail [here](https://rekt.news/templedao-rekt/).


### Brief Description

The root cause of the attack is that the `migrateStake(address oldStaking, uint amount)` function did not contain any checks that the `oldStaking` parameter was valid.
This meant that an attacker could call `migrateStake` with a dummy staking contract.
This would result in `amount` tokens being credited to their account, since the vulnerable contract believes that the `oldStaking` contract transfered `amount` tokens to it and doesn't verify that the transfer actually happened.


### Vulnerable Code

View the full code on [Etherscan](https://etherscan.io/address/0xd2869042e12a3506100af1d192b5b04d65137941#code).

```solidity
    // StaxLPStaking.sol

    /**
      * @notice For migrations to a new staking contract:
      *         1. User/DApp checks if the user has a balance in the `oldStakingContract`
      *         2. If yes, user calls this function `newStakingContract.migrateStake(oldStakingContract, balance)`
      *         3. Staking balances are migrated to the new contract, user will start to earn rewards in the new contract.
      *         4. Any claimable rewards in the old contract are sent directly to the user's wallet.
      * @param oldStaking The old staking contract funds are being migrated from.
      * @param amount The amount to migrate - generally this would be the staker's balance
      */
    function migrateStake(address oldStaking, uint256 amount) external {
        StaxLPStaking(oldStaking).migrateWithdraw(msg.sender, amount);  // VULN: Caller expects `amount` tokens to be transfered to them
        _applyStake(msg.sender, amount);  // Credits `amount` tokens to sender
    }

    function _applyStake(address _for, uint256 _amount) internal updateReward(_for) {
        _totalSupply += _amount;
        _balances[_for] += _amount;
        emit Staked(_for, _amount);
    }

    function withdrawAll(bool claim) external {
        _withdrawFor(msg.sender, msg.sender, _balances[msg.sender], claim, msg.sender);
    }

    /**
      * @notice For migrations to a new staking contract.
      *         1. Withdraw `staker`s tokens to the new staking contract (the migrator)
      *         2. Any existing rewards are claimed and sent directly to the `staker`
      * @dev Called only from the new staking contract (the migrator).
      *      `setMigrator(new_staking_contract)` needs to be called first
      * @param staker The staker who is being migrated to a new staking contract.
      * @param amount The amount to migrate - generally this would be the staker's balance
      */
    function migrateWithdraw(address staker, uint256 amount) external onlyMigrator {
        _withdrawFor(staker, msg.sender, amount, true, staker);
    }

    function _withdrawFor(
        address staker,
        address toAddress,
        uint256 amount,
        bool claimRewards,
        address rewardsToAddress
    ) internal updateReward(staker) {
        require(amount > 0, "Cannot withdraw 0");
        require(_balances[staker] >= amount, "Not enough staked tokens");

        _totalSupply -= amount;
        _balances[staker] -= amount;

        stakingToken.safeTransfer(toAddress, amount);
        emit Withdrawn(staker, toAddress, amount);
     
        if (claimRewards) {
            // can call internal because user reward already updated
            _getRewards(staker, rewardsToAddress);
        }
    }

```

### Attack Scheme

The attacker calls `migrateStake()` a dummy staking contract that does nothing upon being called. The vulnerable staking contract credits `amount` token to the attacker's name, which the attacker can immediately withdraw and swap for stablecoins.


#### Mitigation

The attack is effectively prevented by verifying that the expected transfer actually occured (eg. by checking the token balances before and after the transfer, while also accounting for *reentrancy* attacks).


### Simulate the Attack

Inside `~/hardhat-projects/12-templedao-stax-rekt/` run:

Terminal #0:

```bash
$ npx hardhat node
```

Terminal #1:
```bash
$ node scripts/execute.js
```

You should end up with around $2.3 USDC credited to the attacker's account in Terminal #0.
