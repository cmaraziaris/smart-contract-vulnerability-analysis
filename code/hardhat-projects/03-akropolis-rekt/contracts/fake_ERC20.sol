// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.4.17 <0.9.0;

import "hardhat/console.sol";

contract FakeERC20 {

    string tokenSymbol = "HMC";
    address tokenOwner;
    uint256 tokenTotalSupply;
    mapping (address => uint256) tokenBalance;
    mapping (address => mapping (address => uint256)) tokenAllowance;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    constructor() payable public {
        tokenOwner = msg.sender;
    }

    function symbol() public view returns (string memory) {
        return tokenSymbol;
    }
    
    function decimals() external view returns (uint256 digits) {
        return 18;
    }

    function totalSupply() public view returns (uint256) {
        return tokenTotalSupply;
    }
    
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return tokenBalance[_owner];
    }

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require( tokenBalance[msg.sender] >= _value, "Not enough balance!" );
        tokenBalance[_to] += _value;
        tokenBalance[msg.sender] -= _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return tokenAllowance[_owner][_spender];
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
        tokenAllowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    // function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    //     require( tokenAllowance[_from][msg.sender] >= _value && _value > 0, "Not enough allowance!" );
    //     require( tokenBalance[_from] >= _value, "Not enough balance!" );
    //     tokenBalance[_to] += _value;
    //     tokenBalance[_from] -= _value;
    //     tokenAllowance[_from][msg.sender] -= _value;
    //     emit Transfer(_from, _to, _value);
    //     return true;
    // }
    
    function mint(address _recipient, uint256 _amount) public returns (bool success) {
        require( msg.sender == tokenOwner, "Error: mint can only be called from the owner of the token" );
        tokenBalance[_recipient] += _amount;
        tokenTotalSupply += _amount;
        emit Transfer(address(0), _recipient, _amount);
        return true;
    }
    
    function burn(address payable _recipient, uint256 _amount) public returns (bool success) {
        require( tokenBalance[_recipient] >= _amount, "Not enough balance!" );

        // ? Not sure if this is done correctly
        uint256 eth_burnt = _amount * address(this).balance / tokenTotalSupply;
        
        // "Safe" version
        // tokenBalance[_recipient] -= _amount;
        // tokenTotalSupply -= _amount;
        // (bool sent, ) = _recipient.call{value : eth_burnt}("");
        // require(sent, "Failed to send Ether");
        // /"Safe" version
        console.log("About to burn $", eth_burnt, "$ WEI to address: ", _recipient);
        // Re-entrancy
        (bool sent, ) = _recipient.call{value : eth_burnt}("");
        require(sent, "Failed to send Ether");
        // tokenBalance[_recipient] -= _amount;
        // tokenTotalSupply -= _amount;
        /* 
         * Since Solidity 0.8.0, all arithmetic operations revert on over- 
         * and underflow by default, thus making the use of these libraries unnecessary.
         */
        tokenBalance[_recipient] -= _amount;
        tokenTotalSupply -= _amount;

        // /Re-entrancy
        console.log("Just sent $", eth_burnt, "$ WEI to address: ", _recipient);
        console.log("Address tokens remaining: ", tokenBalance[_recipient] );

        emit Transfer(_recipient, address(0), _amount);
        return true;
    }
    
    receive() external payable { }
    
    fallback() external payable { }
    
    function getContractBalance() public view returns (uint256) {
        return address(this).balance;
    }
}