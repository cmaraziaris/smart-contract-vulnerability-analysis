
# Attack #3: Akropolis

## Attack Classification

Reentrancy, Fake ERC20-token, faulty deposit/mint logic, no proper caller-input validation, resulted in money loss (>$2M)

## Attack Vector

The attack vector is described in full detail [here](https://rekt.news/akropolis-rekt/) and [here](https://peckshield.medium.com/akropolis-incident-root-cause-analysis-c11ee59e05d4)

### Brief Description

This attack was possible because the protocol (1) did not validate the supported tokens and (2) did not enforce reentrancy protection on the deposit logic. This allowed the attacker to use his custom malicious ERC20 token to reenter the contract and register 2 deposits, while actually performing just 1. The exploitation leads to a large number of pooltokens minted without being backed by valuable assets. The redemption of these minted pooltokens is then exercised to drain about 2M DAI from the affected YCurve and sUSD pools.

### Vulnerable Code

View the full code on [Github](https://github.com/akropolisio/delphi/blob/release-1.0/contracts/modules/savings/SavingsModule.sol#L217-L287)

```solidity
/**
     * @notice Deposit tokens to a protocol
     * @param _protocol Protocol to deposit tokens
     * @param _tokens Array of tokens to deposit
     * @param _dnAmounts Array of amounts (denormalized to token decimals)
     */
    function deposit(address _protocol, address[] memory _tokens, uint256[] memory _dnAmounts)
    public operationAllowed(IAccessModule.Operation.Deposit)
    returns(uint256) 
    {
        // [...]
        uint256 nBalanceBefore = distributeYieldInternal(_protocol);
        depositToProtocol(_protocol, _tokens, _dnAmounts);  // VULN: Reentrancy happens here
        uint256 nBalanceAfter = updateProtocolBalance(_protocol);

        PoolToken poolToken = PoolToken(protocols[_protocol].poolToken);
        uint256 nDeposit = nBalanceAfter.sub(nBalanceBefore);
        // [...]

        uint256 fee;
        if(nAmount > nDeposit) {
            fee = nAmount - nDeposit;
            poolToken.mint(_msgSender(), nDeposit);
        } else {
            fee = 0;
            poolToken.mint(_msgSender(), nAmount);
            // [...]
            }
        }
        // [...]
        return nDeposit;
    }

    function depositToProtocol(address _protocol, address[] memory _tokens, uint256[] memory _dnAmounts) internal {
        require(_tokens.length == _dnAmounts.length, "SavingsModule: count of tokens does not match count of amounts");
        for (uint256 i=0; i < _tokens.length; i++) {
            address tkn = _tokens[i];  // VULN: Reentrancy happens in the `safeTransferFrom` which reenters `deposit`
            IERC20(tkn).safeTransferFrom(_msgSender(), _protocol, _dnAmounts[i]);
            IDefiProtocol(_protocol).handleDeposit(tkn, _dnAmounts[i]);
            // [...]
        }
    }
```

This code is the core deposit logic of the Akropolis smart contract.


### Attack Scheme

<!-- /*
    Exploit logic:
    1) Somehow obtain some (1000 here) DAI (can be done via FL)
    2) Call Akropolis with X amount of Fake Token
    2.5) Reenter Akropolis via Fake Token's transferFrom - send X DAI to AKRO
    3) Burn the dsUSD (Akro token) obtained -> Take 2*X real DAI (twice the amount sent from transferFrom)
    4) GOTO (2)
*/
 -->

#### TL:DR

We need to create an ERC20-conforming contract, with a malicious `transferFrom` method, that will be used to reenter the `deposit()` function and effectively credit us for double the amount of the actual deposit made.

#### Longer explanation

(In this implementation, we target the underlying `sUSD` pool of [Curve.fi](https://github.com/curvefi/curve-contract) (for which Akropolis mines `dsUSD` tokens), for a total of about `~1.3M DAI`. The actual attack also targeted the `Y` pool, for about 700K DAI.)


We observe that the internal `depositToProtocol()` function (called by the public `deposit()` function) gives control to a `transferFrom()` function of a **caller-specified** ERC20 token.
With every deposit to the Akropolis protocol, the depositor gets mined Akropolis tokens which differ on the basis of the protocol of deposit.
The minted tokens are proportional to the deposited amount.
We observe that the calculation of the deposited amount `nDeposit = nBalanceAfter.sub(nBalanceBefore);` depends on `nBalanceBefore` and on `nBalanceAfter`, which are calculated before and after the deposit call, respectively.
With no apparent reentrancy protection mechanism (such as a lock), the attack vector consists of:
1) Call `deposit()` with an X amount of our Malicious ERC20 token.
2) The Malicious `transferFrom()` calls again `deposit()`, this time actually depositing a X amount of DAI.
3) The 2nd `deposit()` call terminates and credits (by minting `dsUSD`) our Malicious ERC20 contract for X DAI.
4) The 1st `deposit()` call terminates and credits our contract for X DAI, since during the call, the balance of DAI shifted by +X.
5) Therefore, if we use the same Malicious ERC20 contract to perform actions 1-4, we end up losing an X amount of DAI while gaining 2X. So we profit +X DAI.
6) We withdraw the 2X DAI from the Akropolis protocol by redeeming the minted tokens.
7) We repeat steps 1-6 until we drain the Akropolis' DAI reserves on the `sUSD` pool.

#### Mitigation

The attack is effectively prevented by using a Reentrancy guard in the `deposit()` function.


## Simulate the Attack

Inside `~/hardhat-projects/akropolis-rekt/` run:

Terminal #0:

```bash
$ npx hardhat node
```

Terminal #1:
```bash
$ node scripts/execute.js
```

You should end up with around 2,745 WETH (`~$1.3M`) credited to the attacker's account in Terminal #0.

## Notes

In this implementation, we target the underlying `sUSD` pool of [Curve.fi](https://github.com/curvefi/curve-contract) for a total of about `~1.3M DAI`. The actual attack also targeted the `Y` pool, for about 700K DAI. The logic applied and the vulnerability exploited are the same.