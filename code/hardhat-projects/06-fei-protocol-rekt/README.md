
# Attack #6: Fei protocol / Rari capital

## Attack Classification

reentrancy, missing check-effect-interaction pattern, low-level call to transfer ETH, resulted in money loss (>$80M)


## Attack Vector

The attack vector is described in full detail [here](https://twitter.com/Hacxyk/status/1520370421773725698), [here](https://certik.medium.com/fei-protocol-incident-analysis-8527440696cc) and [here](https://rekt.news/fei-rari-rekt/).

### Brief Description

The root cause of this attack stems from a Reentrancy security loophole where an attacker is able to borrow assets yet withdraw all the deposited collateral. Specifically, the attacker flashloaned multiple tokens/WETH as collateral and borrowed assets from the pool. However, as the code implementation does not apply the practice of the check-effect-interaction pattern, the result means that the attacker can invoke "exitMarket()" to withdraw all his collateral as the borrow records are not properly updated, while still getting away with the borrowed assets.

### Vulnerable Code

View the full code on [Etherscan](https://etherscan.io/address/0x26267e41ceca7c8e0f143554af707336f27fa051#code).

```solidity
    /**
      * @notice Users borrow assets from the protocol to their own address
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        // [...]

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */

        doTransferOut(borrower, borrowAmount);  // VULNERABLE

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;
        // [...]
    }

    function doTransferOut(address payable to, uint amount) internal {
        // Send the Ether and revert on failure
        (bool success, ) = to.call.value(amount)("");  // VULN: Reentrancy
        require(success, "doTransferOut failed");      // attacker calls exitMarket()
    }

   /**
     * @notice Removes asset from sender's account liquidity calculation
     * @dev Sender must not have an outstanding borrow balance in the asset,
     *  or be providing neccessary collateral for an outstanding borrow.
     */
    function exitMarket(address cTokenAddress) external returns (uint) {
        CToken cToken = CToken(cTokenAddress);
        /* Get sender tokensHeld and amountOwed underlying from the cToken */
        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);  // VULN: Not updated in reentrant call
        // [...]
    }
```

### Attack Scheme

The vulnerability can be exploited in the following scenario:
1) Flashloan asset and deposit into FEI
2) Borrow ETH, which triggers re-entrancy (debt not updated yet)
3) Call `exitMarket()` via the `fallback` function. Now the asset is no longer collateral and can be withdrawn.
4) Repay flashloan
5) Attacker gets borrowed ETH for free

Furthermore, the attacker can deposit ETH, borrow varius assets, and then use steps 1-5 to withdraw his deposited ETH, thus getting away with the borrowed assets aswell for free.

#### Mitigation

This attack is probably prevented by securing the `exitMarket()` function with a `nonReentrant` modifier. Alternatively, a change in logic could be that all transactions involving ETH could be done using WETH instead, thus removing the low-level `call`.


### Simulate the Attack

Inside `~/hardhat-projects/fei-protocaol-rekt/` run:

Terminal #0:

```bash
$ npx hardhat node
```

Terminal #1:
```bash
$ node scripts/execute.js
```

We simulated [this transaction](https://etherscan.io/tx/0xab486012f21be741c9e674ffda227e30518e8a1e37a5f1d58d0b0d41f6e76530), which includes steps 1-5 and also the theft of other assets, namely USDT, USDC and FRAX, as described in the **Attack Scheme**, for a total amount of around $14M out of the total $80M exploited.

The initial capital is obtained by the use of AAVE Flash Loans.

Finally, you should end up with around $14M in various tokens credited to the attacker's personal account in Terminal #0.