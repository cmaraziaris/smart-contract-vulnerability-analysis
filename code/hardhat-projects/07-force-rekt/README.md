
# Attack #7: FORCE DAO

## Attack Classification

missing check-effect-interaction pattern, resulted in money loss (>$10M)

Wrong assumption: `token.transferFrom` will always revert on failure


## Attack Vector

The attack vector is described in full detail [here](https://twitter.com/FrankResearcher/status/1378633815111954432) and [here](https://rekt.news/force-rekt/).


### Brief Description

The cause of this attack is a missing check on whether a transfer succeeded or not. In the case of success, the contract should mine tokens and in the case of failure, the function should revert. With no checks performed, the attacker could request a transfer of an arbitrary large amount of tokens without holding them, the transfer would fail, but the corresponing amount of minted tokens would be credited to his account (as if the transfer was successful). The attacker could later redeem/burn the minted tokens for actual tokens and swap them for ETH.

### Vulnerable Code

View the full code on [Etherscan](https://etherscan.io/address/0xe7f445b93eb9cdabfe76541cc43ff8de930a58e6#code).

```solidity
/* xFORCE contract */
    
    function deposit(uint256 amount) external nonReentrant {
        // Gets the amount of Force locked in the contract
        uint256 totalForce = force.balanceOf(address(this));
        // Gets the amount of xForce in existence
        uint256 totalShares = totalSupply();
        // If no xForce exists, mint it 1:1 to the amount put in
        if (totalShares == 0 || totalForce == 0) {
            _mint(msg.sender, amount);
        }
        // Calculate and mint the amount of xForce the Force is worth. The ratio will change overtime, as xForce is burned/minted and Force deposited + gained from fees / withdrawn.
        else {
            uint256 what = amount.mul(totalShares).div(totalForce);
            _mint(msg.sender, what);  // VULN: xFORCE minted before transfer
        }
        // Lock the Force in the contract
        // VULN: Does *not* revert if `transferFrom` is unsuccessful
        force.transferFrom(msg.sender, address(this), amount);

        emit Deposit(msg.sender, amount);
    }

/* FORCE token contract */

	/// @notice Send `_amount` tokens to `_to` from `_from` on the condition it
    ///  is approved by `_from`
    /// @param _from The address holding the tokens being transferred
    /// @param _to The address of the recipient
    /// @param _amount The amount of tokens to be transferred
    /// @return True if the transfer was successful
    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        if (msg.sender != controller) {
            require(transfersEnabled);

            // The standard ERC 20 transferFrom functionality
            if (allowed[_from][msg.sender] < _amount)
                return false;
            allowed[_from][msg.sender] -= _amount;
        }
        // VULN : Might not revert if unsuccessful
        return doTransfer(_from, _to, _amount);
    }

    /// @dev This is the actual transfer function in the token contract, it can
    ///  only be called by other functions in this contract.
    /// @param _from The address holding the tokens being transferred
    /// @param _to The address of the recipient
    /// @param _amount The amount of tokens to be transferred
    /// @return True if the transfer was successful
    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {
        if (_amount == 0) {
            return true;
        }
        require(parentSnapShotBlock < block.number);
        // Do not allow transfer to 0x0 or the token contract itself
        require((_to != 0) && (_to != address(this)));
        // If the amount being transfered is more than the balance of the
        //  account the transfer returns false
        var previousBalanceFrom = balanceOfAt(_from, block.number);
        if (previousBalanceFrom < _amount) {
            return false;  // VULN: Does not revert
        }
        // Alerts the token controller of the transfer
        if (isContract(controller)) {
            // Adding the ` == true` makes the linter shut up so...
            require(ITokenController(controller).onTransfer(_from, _to, _amount) == true);
        }
        // First update the balance array with the new value for the address
        //  sending the tokens
        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);
        // Then update the balance array with the new value for the address
        //  receiving the tokens
        var previousBalanceTo = balanceOfAt(_to, block.number);
        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow
        updateValueAtNow(balances[_to], previousBalanceTo + _amount);
        // An event to make the transfer easy to find on the blockchain
        Transfer(_from, _to, _amount);
        return true;
    }

```

### Attack Scheme

The vulnerability can be exploited in the following scenario:
1) The attacker requests a `deposit` of an arbitrary large amount of `Force` tokens (without owning them).
2) The `xForce` contract mints the corresponding amount of `xForce` tokens.
3) The attacker calls `withdraw` to redeem his `xForce` tokens for actual `Force` tokens.
4) The attacker swaps `Force` tokens for `WETH`.

#### Mitigation

This attack is probably prevented by reverting the execution if the `transferFrom` returns `false`.


### Simulate the Attack

Inside `~/hardhat-projects/7-force-rekt/` run:

Terminal #0:

```bash
$ npx hardhat node
```

Terminal #1:
```bash
$ node scripts/execute.js
```

In our simulation, we used `Uniswap` and `SushiSwap` pools to swap `FORCE` to `WETH`, instead of using `1inch` as in the original exploit.

Finally, you should end up with around `67 WETH` (around $140k) credited to the attacker's contract in Terminal #0.